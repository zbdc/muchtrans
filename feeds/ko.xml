<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
<channel>
  <title>muchtrans</title>
  <link>https://muchtrans.com</link>
  <description>There are too much cool text to be translated in this world.</description>
  <pubDate>Tue, 12 Feb 2019 07:42:17 +0000</pubDate>
  <language>ko</language>
  
  <item>
    <title>October 21 post-incident analysis</title>
    <link>https://muchtrans.com/translations/github-oct-21-post-incident-analysis.ko.html</link>
    <description><![CDATA[<h1 id="1">10월 21일 장애 사후 분석</h1>
<p>지난 주, 깃헙(GitHub)에 <a href="https://blog.github.com/2018-10-21-october21-incident-report/">문제가 발생</a>해 24시간 11분 동안 제한된 서비스만 제공할 수 있었습니다. 일부 플랫폼은 영향 밖에 있었지만, 많은 내부 시스템이 영향을 받아 일관되지 않고 부정확한 정보를 표시하는 문제가 있었습니다. 최종적으로 어떠한 사용자 데이터도 잃어버리진 않았습니다. 하지만 데이터베이스 쓰기 작업에 대한 수 초간의 수동 조작은 아직 진행중입니다. 대부분의 문제는 웹훅 이벤트를 제공하지 못하거나 깃헙 페이지 사이트를 만들고 퍼블리싱하지 못하는 것이었습니다.</p>
<p>깃헙 구성원 모두는 이 사건이 일어난 것에 대해 여러분 한 분 한 분에게 진심으로 사과의 말씀을 드립니다. 깃헙에 대한 여러분의 신뢰를 잘 이해하고 고가용성 플랫폼을 구축하는 저희의 탄력적 시스템 구축 기술에 자부심도 가지고 있습니다. 이번 사건으로 여러분에게 실망을 드려 대단히 죄송합니다. 깃헙 플랫폼을 사용할 수 없었던 긴 시간동안 이로 인해 발생한 문제들을 저희가 되돌릴 수는 없겠지만, 문제의 원인과 이번 사고를 통해 저희가 배운 것들, 그리고 이런 일이 다시는 일어나지 않도록 회사 입장에서 취할 수 있는 조치에 대해 설명드리고 싶습니다.</p>
<h2 id="2">사건 배경</h2>
<p>사용자에게 노출되는 깃헙 서비스의 대부분은 저희의 자체 <a href="https://githubengineering.com/evolution-of-our-data-centers/">데이터 센터</a>에서 동작하고 있습니다. 데이터 센터의 구성은 연산과 저장을 수행하는 여러 지역의 데이터 센터의 앞단에서 견고하고 유연한 엣지 네트워크를 제공하도록 설계되어 있습니다. 이렇게 설계된 물리적이며 논리적인 컴포넌트 위에 여러 층으로 구성된 견고함에도 불구하고, 여전히 일정 시간 동안 사이트가 서로 통신할 수 없을 수도 있습니다.</p>
<p>10월 21일 22:52 UTC에 망가진 100G 광통신 장비를 교체하는 정기 보수 작업으로 인해 미 동부 해안 네트워크 허브와 주 데이터 센터인 미 동부 데이터 센터간의 연결이 끊겼습니다. 양측의 연결은 43초만에 복구되었습니다만, 이 짧은 끊김으로 인해 24시간 11분간의 서비스 장애가 이어졌습니다.</p>
<p><img src="https://blog.github.com/assets/img/2018-10-25-oct21-post-incident-analysis/network-architecture.png" alt="2개의 물리적 데이터 센터와 3개의 팝, 다양한 지역에 위치한 클라우드 사이의 직접 연결을 포함한 깃헙 네트워크의 개괄적 묘사"></p>
<p>예전에 저희가 어떻게 <a href="https://githubengineering.com/orchestrator-github">MySQL으로 깃헙 메타데이터 저장하는지</a>와 <a href="https://githubengineering.com/mysql-high-availability-at-github">고가용성 MySQL 운영</a>에 대해 논한 적이 있습니다. 깃헙은 수백 기가바이트에서 5 테라바이트에 이르는 다양한 크기의 여러 MySQL 클러스터를 여러 개의 읽기 복제본과 함께 운영하여 깃과 무관한 메타데이터를 저장하고 있습니다. 깃 오브젝트 저장소 외에 풀 리퀘스트와 이슈, 인증 관리, 백그라운드 작업 조율 외 다양한 기능들이 이에 해당합니다. 응용 프로그램의 여러 부분의 서로 다른 데이터들은 기능별 샤딩을 통해 나뉘어 여러 클러스터에 저장됩니다.</p>
<p>대규모 서비스에서의 성능 향상을 위해 응용 프로그램은 클러스터내 연관된 주 저장소(primary)에 직접 쓰지만, 대부분의 읽기 요청은 읽기 복제본에 위임하는 편입니다. MySQL 클러스터 구성 관리와 자동 복구를 위해 <a href="https://github.com/github/orchestrator">Orchestrator</a>를 쓰고 있습니다. Orchestrator는 이 과정에서 여러 변수를 고려하여 동작하며, 합의를 위해 <a href="https://raft.github.io/">Raft</a>를 기반으로 만들어졌습니다. Orchestrator는 응용 프로그램이 지원하지 못하는 수준의 구성이 가능하므로 Orchestrator의 설정을 응용 프로그램의 수준에 맞춰 운영하기 위해서는 주의가 필요합니다.</p>
<p><img src="https://blog.github.com/assets/img/2018-10-25-oct21-post-incident-analysis/normal-topology.png" alt="일반적인 구성에서, 모든 응용 프로그램이 짧은 지연 시간으로 읽기를 수행하는 모습."></p>
<h2 id="3">사건 타임라인</h2>
<h3 id="4">2018년 10월 21일 22:52 UTC</h3>
<p>위에서 설명한 것과 같이 네트워크가 나뉜동안, 주 데이터센터에서 동작하던 Orchestrator는 Raft의 합의 원칙에 따라 리더쉽 선택 취소 프로세스를 시작했습니다. 서부 해안 데이터센터와 동부 해안 공용 클라우드의 Orchestrator 노드들은 (합의에 필요한) 정족수를 채우고 서부 해안 데이터센터에 직접 데이터를 쓰도록 클러스터를 복구할 수 있었습니다. Orchestrator는 서부 해안 데이터베이스 클러스터 구성을 조직하기 시작했고, 연결이 복원되자마자 응용 프로그램들은 일제히 새롭게 선출된 서부 해안 쪽으로 데이터를 쓰기 시작했습니다.</p>
<p>동부 해안 데이터센터에 있는 데이터베이스 서버에는 아직 서부 해안 쪽으로 복제되지 않은 쓰기 작업들이 남아 있었습니다. 양쪽 데이터센터에 서로에게 있지 않은 쓰기 작업들이 남게된 것입니다. 이로 인해 동부 해안의 데이터센터에서는 주 데이터베이스 선정 작업이 실패하게 되었습니다.</p>
<h3 id="5">2018년 10월 21일 22:54 UTC</h3>
<p>내부 모니터링 시스템이 깃헙 시스템에 여러 문제가 발생했다고 알리기 시작했습니다. 이 때부터 많은 엔지니어들이 몰려 들어오는 알림을 분류하고 응답하기 시작했습니다. 23:02 UTC에 최초 대응팀의 엔지니어들은 데이터베이스 클러스터가 예상하지 않은 상태로 구성되어 있다고 판단했습니다. Orchestrator API의 쿼리 결과는 서부 해안 데이터센터의 서버들만 표시하고 있었습니다.</p>
<h3 id="6">2018년 10월 21일 23:07 UTC</h3>
<p>이 시점에 대응팀은 추가적인 변경 내용이 적용되는 것을 막기 위해 내부 배포 도구를 수동으로 잠그기로 결정했습니다. 23:09 UTC에 <a href="https://twitter.com/githubstatus/status/1054147648930897920">일부 장애 상황(yellow status)</a>을 선언했습니다. 이는 현재 상태를 ‘실제 문제 상황’으로 승격시켜 자동으로 사건 담당자에게 알림이 가도록 했습니다. 23:11 UTC에 사건 담당자가 팀에 합류하여 2분 뒤 <a href="https://twitter.com/githubstatus/status/1054148705450946560">심각한 장애 상황(status red)</a>으로 변경하였습니다.</p>
<h3 id="7">2018년 10월 21일 23:13 UTC</h3>
<p>여러 데이터베이스 클러스터에 걸쳐 문제가 있음을 이 시점에서야 알게 되었습니다. 깃헙의 데이터베이스 엔지니어링 팀의 엔지니어들이 추가적으로 호출되었습니다. 그들은 각 클러스터에서 동부 해안 데이터베이스를 주 데이터베이스로 승격 시키고 구성을 복구 하기 위해 어떤 수작업이 필요한지 상황을 분석하기 시작했습니다. 이미 서부 해안의 데이터센터에 40여 분간 쓰기 작업이 이뤄졌기 때문에 작업하기가 매우 어려웠습니다. 그 뿐만 아니라 서부 해안에 복제되지 않고 동부 해안에서 복제가 막혀있는 몇 초간 작성되어 동부 해안에만 남아있는 쓰기 작업도 있었습니다.</p>
<p>사용자 데이터의 기밀성과 무결성 유지는 깃헙의 최우선 과제입니다. 서부 해안에만 30분 이상 기록된 사용자 데이터를 안전하게 보존하기 위해 장애 조치를 내리는 것 외에는 다른 선택이 없었습니다. 하지만 동부 해안에서 실행되는 응용 프로그램들 중 서부 해안의 MySQL 클러스터에 쓰기에 의존하는 것들은 대부분의 데이터베이스 호출에 대륙을 왕복하는 지연 시간으로 인해 제대로 대처할 수 없는 상황이었습니다. 이로 인해 많은 사용자가 서비스를 이용할 수 없게 되었습니다. 하지만 서비스 장애 상황을 확대시켜서라도 데이터 일관성을 유지하는 것이 중요하다고 믿습니다.</p>
<p><img src="https://blog.github.com/assets/img/2018-10-25-oct21-post-incident-analysis/invalid-topology.png" alt="잘못된 구성에서, 서부에서 동부로의 복제가 중단되고 응용 프로그램들이 트랜잭션 성능 유지를 위해 짧은 대기 시간을 기준으로 선택한 복제본에서 읽을 수 없는 상황."></p>
<h3 id="8">2018년 10월 21일 23:19 UTC</h3>
<p>데이터베이스 클러스터의 상태를 조회한 결과 푸시와 같은 메타데이터를 기록하는 작업들을 중단해야 함이 분명해졌습니다. 사용자 데이터를 위태롭게 만드는 대신 웹 훅과 깃헙 페이지 생성을 일시 중지하여 사이트 사용성을 낮추는 명확한 선택을 했습니다. 즉, 사이트 가용성과 복구에 걸리는 시간보다 데이터 무결성에 더 높은 우선 순위를 부여하는 것이 저희의 전략이었습니다.</p>
<h3 id="9">2018년 10월 22일 00:05 UTC</h3>
<p>사고 대응팀에 속한 엔지니어들은 데이터 불일치를 해결하기 위한 계획 수립과 더불어 MySQL 복원 프로시져를 구현하기 시작했습니다. 우선 백업으로부터 복원한 다음 양쪽 사이트에 있는 복제본을 동기화한 후, 데이터베이스 구성을 안정화하여 걸려 있는 작업들을 계속해서 수행하는 계획을 세웠습니다. 내부 데이터 저장 시스템을 절차에 따라 복원할 예정임을 <a href="https://github.com/summernote/summernote/pull/3004">사용자들에게 알렸습니다</a>.</p>
<p><img src="https://blog.github.com/assets/img/2018-10-25-oct21-post-incident-analysis/recovery-flow.png" alt="복구 계획의 개요. Fail forward, synchronize, fall back, then churn through backlogs before returning to green."></p>
<p>수 년간 4시간 단위로 MySQL 데이터 백업이 이뤄지고 있었지만, 백업은 원격에 있는 공용 퍼블릭 클라우드의 BLOB 저장 서비스에 보관되어 있었습니다. 수 테라바이트에 이르는 여러 개의 백업 데이터를 복원하느라 많은 시간이 필요했습니다. 특히 원격 백업 서비스로부터 데이터를 전송해오는데 많은 시간이 소요되었습니다. 새로 인증된 MySQL 서버로 큰 백업 파일들을 불러와 압축 해제하고 무결성 검사를 한 후 준비해서 밀어넣는데 대부분의 시간을 썼습니다. 매일 테스트 하던 작업이라 복원하는데 얼마나 시간이 걸릴지는 예상할 수 있었지만, 이 사고가 나기 전까지는 백업으로부터 전체 클러스터를 완전히 새로 구성해본 적이 없었기 때문에 지연된 복제본 등의 다른 전략에 의존하는 수 밖엔 없었습니다.</p>
<h3 id="10">2018년 10월 22일 00:41 UTC</h3>
<p>사고 영향을 받은 모든 MySQL 클러스터의 백업 프로세스가 시작되어 엔지니어들이 이를 모니터링 하고 있었습니다. 동시에 여러 팀의 엔지니어들이 데이터 손상이나 사이트 사용성을 저하시키지 않고 데이터 전송과 복원 시간을 줄일 방법을 조사하고 있었습니다.</p>
<h3 id="11">2018년 10월 22일 06:51 UTC</h3>
<p>몇몇 클러스터들은 동부 해안 데이터센터에서의 복원을 완료하고 서부 해안쪽에서의 새로운 데이터를 복제하기 시작했습니다. 대륙간 링크를 통해 쓰기 작업이 시작되느라 페이지 표시가 느려지기 시작했습니다. 대신 이 데이터베이스 클러스터에 속한 페이지를 읽을 때는 새롭게 복제된 곳에서 요청을 받아 최신의 데이터를 표시할 수 있게 되었습니다. 더 큰 데이터베이스 클러스터들은 여전히 복원중이었습니다.</p>
<p>팀은 서부 해안 쪽에서 직접 복원할 수 있는 방법을 찾아내어, 원격 저장소에서 다운로드 받아 복원하느라 오래 걸리던 문제를 해결하고 곧 복원을 완료할 수 있다고 확신했습니다. 구성을 정상화시키는데는 이제 복제 과정이 얼마나 오래 걸리느냐에 달려있었습니다. 원격에서 복원하던 것에 비해 선형적으로 추정할 수 있게 되었으며, 상태 페이지를 복구까지 약 2시간 정도 남은 것으로 예상한다고 <a href="https://twitter.com/githubstatus/status/1054264047250608130">갱신</a>할 수 있었습니다.</p>
<h3 id="12">2018년 10월 22일 07:46 UTC</h3>
<p>깃헙은 더 많은 맥락을 전달하기 위해 <a href="https://blog.github.com/2018-10-21-october21-incident-report">블로그 포스트</a>를 올렸습니다. 이를 위해 내부적으로 깃헙 페이지를 사용하고 있었는데, 이 서비스는 몇 시간 전부터 정지되어 있었으므로 블로그를 발행하기 위해 몇몇 작업을 하느라 발행이 더 늦어졌습니다. 죄송합니다. 더 빨리 알렸어야 했는데 앞으로는 이런 상황 속에서도 더 빨리 상태를 알릴 수 있도록 하겠습니다.</p>
<h3 id="13">2018년 10월 22일 11:12 UTC</h3>
<p>모든 주 데이터베이스가 동부 해안 데이터센터로 다시 설정되었습니다. 이에 쓰기 작업이 물리적으로 같은 곳의 데이터베이스 서버로 이뤄져 사이트의 반응이 훨씬 나아졌습니다. 성능은 눈에 띄게 향상되었지만 여전히 읽기 데이터베이스 노드로 복제해야 수 시간의 분량이 남아 있는 상태였습니다. 지연된 복제로 인해 서비스를 이용하는 사용자들은 일관성 없는 데이터를 보게 되었습니다. 여러 읽기 복제본에 읽기 작업을 분산시키다보니 여전히 몇 시간이나 뒤쳐진 읽기 복제본에서 요청을 처리하는 경우가 많았습니다.</p>
<p>실제로 복제본이 따라잡는데 필요한 예상 시간은 선형적이라기 보다는 멱함수(power delay function)에 가까웠습니다. 유럽과 미국의 근무 시간이 시작되면서 데이터베이스 클러스터로의 쓰기 요청이 많아져 복구에 걸리는 시간은 예상했던 것보다 길어졌습니다.</p>
<h3 id="14">2018년 10월 22일 13:15 UTC</h3>
<p>이제 깃헙의 최대 트래픽에 다다르고 있었습니다. 사고 대응팀에서는 어떻게 할 것인가에 대한 토론을 거쳤습니다. 복제에 걸리는 지연은 줄어들기는 커녕 증가하고 있음이 분명했습니다. 사고가 일어났을 초기에 동부 해안쪽의 공용 클라우드에 MySQL 읽기 사본을 추가해둔 상태였습니다. 이것을 사용할 수 있게 되면 더 많은 서버에 읽기 요청을 분산하기 용이해집니다. 전체적인 사용율을 낮추면 복제본이 따라잡기도 더 쉬워질 것입니다.</p>
<h3 id="15">2018년 10월 22일 16:24 UTC</h3>
<p>복제본이 동기화되는 대로 바로 원래 구성으로 돌아가게 장애 조치를 취하고 바로 지연과 가용성 문제를 다뤘습니다. 사고 시간을 줄이는 것보다 데이터 무결성을 최우선 한다는 결정하에, 백로그를 처리하는 중에도 여전히 <a href="https://twitter.com/githubstatus/status/1054408042836606977">심각한 장애 상황(status red)</a>을 유지하였습니다.</p>
<h3 id="16">2018년 10월 22일 16:45 UTC</h3>
<p>이 복구 단계에서는 백로그에 의해 증가하는 부하를 다루는 것과 깃헙 생태계의 파트너들에 보내는 알림(notification)들, 그리고 서비스를 최대한 빠르게 100% 복원하는 것 사이에서 균형을 잡아야 했습니다. 500만개 이상의 훅 이벤트와 8만 개 이상의 페이지 생성 작업이 기다리고 있었습니다.</p>
<p>이 데이터 처리를 다시 시작하면서 내부적으로 설정된 제한시간(TTL)을 초과하여 취소된 20만개에 가까운 웹훅 요청을 처리하였습니다. 이를 알게되어 처리를 일단 중단하고 임시로 제한시간을 늘려 다시 작업을 진행하도록 했습니다.</p>
<p>상태 알림을 다시 돌리는 일이 없게끔, 백로그를 모두 처리하고 서비스가 완전히 정상적인 수준으로 명확하게 회복될 때까지 장애 상태를 유지하도록 했습니다.</p>
<h3 id="17">2018년 10월 22일 23:03 UTC</h3>
<p>밀려있던 모든 웹훅과 페이지 생성 작업이 처리되었으며 시스템 무결성과 작동이 완전히 확인되었습니다. 드디어 <a href="https://twitter.com/githubstatus/status/1054508689560870912">정상 상태</a>로 돌아왔습니다.</p>
<h2 id="18">앞으로 할 일</h2>
<h3 id="19">데이터 부정합 해결</h3>
<p>복구 과정에서 주 사이트에서 서부 해안 사이트로 복제되지 않은 쓰기 작업을 담고 있는 MySQL 바이너리 로그(binlog)를 영향을 받은 클러스터로부터 캡춰했습니다. 서부로 복제되지 않은 총 쓰기 작업은 상대적으로 적었습니다. 가장 바쁜 클러스터에서도 영향을 받은 윈도우에 954개의 쓰기 작업이 있을 뿐이었습니다. 저희는 이러한 로그에 대한 분석을 진행하고 있으며, 자동적으로 조정될 쓰기 작업과 그렇지 않은 사용자의 개입이 필요한 것들을 분류하고 있습니다. 이 작업을 위해 여러 팀이 노력하고 있으며, 사용자가 반복하여 수행해 성공적으로 쓰여진 작업에 대한 분석은 이미 완료되었습니다. 이 글에서 앞서 언급했던 대로 저희의 최우선 목표는 사용자의 데이터 무결성과 정합성을 유지하는 것입니다.</p>
<h3 id="20">커뮤니케이션</h3>
<p>사건이 진행되는 동안에 저희는 의미있는 정보를 전달하고자, 데이터 백로그 처리율에 근거하여 복원에 필요한 추정 시간을 여러 번 발표했었습니다. 돌이켜보면, 저희의 예상은 모든 변수를 고려하지 못했습니다. 이로 인해 혼란을 야기했던 점에 대해 죄송스러운 마음을 전하며, 앞으로는 더 정확한 정보를 제공하기 위해 노력하겠습니다.</p>
<h3 id="21">기술적 개선안</h3>
<p>분석을 진행하며 확인된 여러 기술적 개선안들이 있습니다. 더 넓은 사후 분석 작업을 통해 앞으로 일어날 수 있는 더 많은 일을 확인할 수 있을 것으로 기대합니다.</p>
<ol>
<li><p>Orchestrator의 설정을 조정하여 지역 경계를 넘는 주 데이터베이스 승격 작업을 방지할 예정니다. Orchestrator는 애플리케이션 쪽에서 변경된 구성을 받아들일 수 없는 상황임에도 불구하고 설정된 대로 동작했습니다. 지역 내에서의 승격 작업은 일반적으로 안전하지만, 대륙간 지연 시간이 갑자기 발생한 것이 이번 사고의 주요 원인이 되었습니다. 내부 네트워크가 단절되는 수준에서는 발견하지 못했던 시스템의 돌발 상황이었습니다.</p>
</li>
<li><p>새로운 상태 보고 체계로의 전환을 더 가속화 하여 의견을 나눌 수 있는 소통 창구의 제공과 현재 상황에 대한 더 명확한 전달이 가능하도록 할 예정입니다. 사고가 발생한 상황에서도 깃헙의 대부분이 가용했음에도 불구하고, 상태를 초록, 노랑 그리고 빨강으로 표현할 수 밖에 없었습니다. 이것으로는 어떤 것들이 동작하는지에 대한 정확한 상황을 전달할 수 없음을 깨닫고, 앞으로는 플랫폼의 서로 다른 부분에 대해 각각의 상태를 표시할 수 있도록 하겠습니다.</p>
</li>
<li><p>이 사건이 발생하기 몇 주 전에, 여러 데이터센터에서 active/active/active 상태로 깃헙 트래픽을 처리할 수 있도록 하는 전사적인 엔지니어링 개선 작업을 시작했습니다. 이 프로젝트의 목표는 저수준에서의 N+1 이중화를 지원하는데 있습니다. 하나의 데이터센터가 완전히 동작하지 않는 상황에서도 사용자에게 영향을 미치지 않는 수준을 목표로 합니다. 많은 노력과 시간이 소요되겠지만, 지리적으로 잘 연결된 여러 사이트가 구성될 수 있을 것입니다. 이번 사건을 통해 우선순위를 높여 작업하게 되었습니다.</p>
</li>
<li><p>보다 적극적으로 상황을 가정하여 테스트할 예정입니다. 깃헙은 지난 10년간 빠르게 성장하고 있으며 그만큼 복잡도도 빠르게 증가하였습니다. 깃헙이 계속 성장함에 따라 새로운 세대의 깃허버(Hubbers)들에게 트레이드 오프와 의사 결정에 대한 역사적인 맥락을 전달하기가 어려워지고 있습니다.</p>
</li>
</ol>
<h3 id="22">조직적 개선안</h3>
<p>이 사고를 계기로 사이트 가용성에 대한 사고 방식 자체가 달라졌습니다. 깃헙과 같이 복잡한 서비스 시스템에서는 엄격한 운영 제어나 개선된 응답 시간만으로는 가용성을 유지하기에 충분치 않음을 알게 되었습니다. 이러한 노력에 더해, 사용자에게 문제가 될만한 장애 시나리오를 검증하는 체계적인 연습을 시작할 예정입니다. 이 작업에는 깃헙의 카오스 엔지니어링 툴링과 결함 주입(fault injection)에 대한 투자가 포함됩니다.</p>
<h2 id="23">결론</h2>
<p>여러분의 프로젝트와 사업의 성공에 깃헙이 얼마나 큰 책임을 지고 있는지 잘 알고 있습니다. 그 누구도 저희 만큼 서비스의 가용성과 데이터의 정합성에 대해 열정을 가지고 있지 않습니다. 더 나은 서비스와 신뢰를 얻기 위해 이번 사건에 대한 분석을 계속해나갈 예정입니다.</p>
]]></description>
    <pubDate>Wed, 07 Nov 2018 08:50:56 +0000</pubDate>
    
    <author>ez.amiryo@gmail.com (Park Hyunwoo)</author>
    
  </item>
  
  <item>
    <title>Techie to tech lead: My five biggest mistakes</title>
    <link>https://muchtrans.com/translations/techie-tech-lead-my-5-biggest-mistakes.ko.html</link>
    <description><![CDATA[<h1 id="1">개발자에서 개발팀장이 되기까지 겪은 다섯가지 큰 실수</h1>
<p>피터 길라드–모스</p>
<p>젊었을 때는 자신의 재능에 확신을 가진 야심 찬 프로그래머로서, 팀장이 되기를 늘 꿈꿨습니다. 그리고 그렇게 되기까지 4년이 채 걸리지 않았죠. 하지만 2년간 팀을 이끌며 느낀 현실은 제게서 리더쉽이라는 것을 완전히 앗아가 버렸습니다. 그 이후로 몇 년 동안 저는 기술의 깊숙한 곳으로 숨어, 더 큰 책임을 요구하는 일에서 도망쳐왔습니다. <sup>(역주: Leader를 팀장으로 의역하였습니다)</sup></p>
<p>시간이 지남에 따라, 제가 저지른 실수들의 근본적인 원인에 대해 이해하여 다시 리더가 되는 기회를 잡아 팀장으로 성장할 수 있었고, 지난 2년간 제대로 된 지원을 받으며 ThoughtWorks의 기술 부문장을 맡을 정도로 성장하였습니다. 다른 리더들에게 가르침을 받으면서 제가 했던 실수들이 저만 겪었던 특별한 일이 아니라, 리더쉽을 요구받는 개발자들이 공통적으로 가질 수 있는 문제임을 알았습니다.</p>
<p>다른 분들에게 도움이 되기를 바라며 제 실수와 그로부터 배운 것들을 공유해봅니다.</p>
<h2 id="2">1: 기술적인 능력이 리더쉽으로 이어질 줄 알았다</h2>
<p>기술 리더 역할을 처음 맡으면서, 젊고 재능있는 졸업생들을 고용했습니다. 우리는 새로운 아이디어와 능력으로 서로 밀어주고 당겨주며 열심히 일했습니다. 고작 몇 달 만에 이 친구들이 경험은 부족할지 몰라도, 저보다 기술적으로 더 뛰어날 수 있다는 것을 깨달았습니다. 기술 리더로서 다른 그 누구보다 기술적으로 뛰어남을 증명해야겠다는 생각이 들었습니다. 그들이 다른 사람에게 – 특히 제 상관에게 – 가능성을 보여줄 때마다 저는 불안해져서, 그들이 저보다 제 역할에 더 어울려 보이지 않을까 안절부절못했습니다. 좋은 동료였던 관계가 제 경쟁심과 불신으로 휩싸였습니다. 그들을 공동 작업자(또는 최소한 잠재적인 후임자)로 여기지 못하고 위협적인 존재로만 여겼습니다.</p>
<p>기술적인 능력이 리더를 선택하는 데 있어 가장 큰 요인으로 주로 사용되곤 합니다. 가장 명확하게 보이는 요인이기도 하고요. 이게 제 첫 번째 실수였습니다. 기술적으로 뛰어난 사람이 리더로의 능력도 클 것으로 착각했죠.</p>
<p>제 경우에는 이 착각이 별 도움도 안 되는 경쟁적인 행동들로 이어졌습니다. 주변 환경과 자격지심 때문에 제 불안은 커져갔습니다. 제아무리 겸손하고 능력 있는 사람이라도 이런 실수는 가면 증후군을 강화해, 팀의 다른 사람들이 훨씬 가치 있다는 생각에 빠지게 만듭니다. 팀워크를 과소평가하거나 자신의 존재 가치에 대해 의문을 가지게 되기도 합니다. 이런 경우에, 리더는 자신의 역할을 믿지 못해 우유부단해지고 필요한 순간에 결정을 내리지 못하게 됩니다.</p>
<p>기술이 뛰어난 사람이 리더가 되어야 한다는 잘못된 생각 때문에, 능력 있는 사람들이 스스로 리더 역할을 꺼리게 됩니다.</p>
<h2 id="3">2: 능력을 넓혀야 할 때 기술에만 집착하고 있었다</h2>
<p>처음 팀장을 맡았을 때 정말 좋았습니다. 완전한 새 프로젝트에 새로운 팀이었으니까요. 유닛 테스팅, ORM, 지속적 통합(CI), 페어 코딩, 더 나은 소스 관리 도구, 빌드 시스템 등 신기술과 방법론들을 도입했습니다. 힙스터의 새로운 블로그 글을 읽으면 바로 회사 프로세스와 도구에 도입해보았습니다.</p>
<p>도구와 기술을 선택하는 것은 처음에만 해당하는 일이었습니다. 이제 날마다 해야 하는 일의 차례였습니다. 관리하고, 관계자들을 설득하고, 팀 회의를 진행하고, 실적 리뷰를 하고, 사람을 뽑고, 예산을 관리하는 일 같은 것들요. SVN, nunit, CruiseControl, C# 같은 건 고를 줄 알았지만 다른 일들은 완전히 처음이었습니다.</p>
<p>제가 이해하지 못하고 어렵다고 생각하는 것들에 점점 화만 쌓여갔습니다. 문제의 원인을 알아보려 하지 않고, 저는 제가 그나마 할 수 있는 것에만 집중했습니다. 바로 기술이죠. 이는 제 가면 증후군을 더 악화시키기만 했는데, 팀 성장에 자신 있어 하는 다른 팀장을 만날 때, 투자를 위한 비즈니스 미팅, 새로운 팀 멤버들이나 장애 복구 계획 등을 얘기할 때 특별히 더 심했습니다.</p>
<p>앞서도 말했지만, 기술적인 역량은 리더의 역할에 얼마나 적합한지를 알려주는 유일한 지표가 아닙니다. 기술적으로 탁월한 것은 여러 부분 중 하나일 뿐입니다. 동료에게 영향을 주고 설득하며 코칭하는 능력, 프로세스에 대한 이해, 신뢰받는 조언, 복잡도를 다루는 능력, 전략적 사고 등 이루 말할 수 없이 많습니다. 이러한 것들은 눈에 잘 띄진 않지만 업무 중에 계속해서 섬세하게 요구되는 역량입니다.</p>
<p>새롭게 리더 역할을 맡게 되면 이런 역량들의 중요성을 이해하고 폭넓은 분야에서 자기 계발을 하는 것이 필요합니다. 그렇지 않으면 가장 눈에 띄는 역량인 ‘기술’에만 불나방처럼 빠져들어 문제를 악화시키게 됩니다.</p>
<p>또 다른 함정은, 개발자들이 새로운 기술 역량을 익히기가 상대적으로 쉽다는 것입니다. 우리는 새로운 기술을 습득하는데 꽤 익숙합니다. 수식을 이해하고, 블로그를 읽으며, 스택오버플로우를 찾아보고, 좋은 리더를 알고 있으며, 컨퍼런스에 참석하며, 책을 봅니다. 적당한 ‘Hello World’ 예제와 몇 번의 시도를 하고 나면 새로운 기술에 이미 익숙해져 있습니다.</p>
<p>하지만 다른 역량은 이렇게 익힐 수 없습니다.</p>
<blockquote><p>코칭이나 시간 관리, 비즈니스 가치에 영향을 주거나 설득하는 방법에 대해서는 명확한 ‘Hello World’가 없습니다.</p>
</blockquote>
<p>우리는 의사 결정을 내리거나 팀을 조직하고 이해 관계자를 이해시키는 ‘올바른 방법’을 듣기 위해 트위터에서 누굴 팔로우 해야 할 지 모릅니다.</p>
<p>리더쉽이 있어야 하는 새로운 역할을 맡을 때는 걸맞는 대가를 치뤄야 합니다. 이러한 것들 중 대부분은 새롭기 때문에 신임 팀장들은 갈팡질팡하게 됩니다. 익숙하지 않은 역량들은 익혀서 어떤 가치를 줄지 알 수 없으므로, 눈에 보여 쉽게 익힐 수 있을 것 같은 기술적 역량을 익히는 데 치중하기가 쉽습니다.</p>
<h2 id="4">3: 계속해서 개발자로 일하려고 했다</h2>
<p>팀장이 되고 나서 처음 몇 달간은 근심이 깊어갔습니다. 개발과는 무관한 일들만 잔뜩 해야 하는 것 같았습니다. 코드를 작성하는 시간은 점점 줄어만 가고, 회의와 이메일, 이해 관계자들을 상대하는 일들로 바빴습니다. 제 이름이 걸린 일들은 진전이 없게 느껴졌고요. 이런 일을 하느라 못했던 것들을 제 개인 시간을 희생해서라도 하려고 했습니다. 당연히 야근으로 이어졌습니다.</p>
<p>개발자에서 개발팀장이 되면서 깨닫지 못한 게 있다면, ‘생산자’라는 관점에서 제 책임과 성공의 척도가 바뀌었다는 것입니다. 전달하는 조직에서는 주된 목표가 생산된 ‘가치’를 극대화 하는 데 있습니다. 이런 관점에서 팀에는 두 가지 주된 활동이 있습니다. 하나는 직접 가치를 창출하는 일과, 다른 하나는 생산된 가치를 극대화하는 일입니다. 이 일을 하기 위한 유일한 방법은 아니지만, 가장 단순한 방법은 생산자(개발자)가 생산 활동(코드를 작성하는 것)에 집중하는 시간을 극대화하는 것입니다. PM부터 XD, BA, QA까지 이르는 다른 팀은 업무 과정이 최대한 정확하고 물처럼 흘러 일이 막히거나 실패 요인(버그 같은 것)을 만들지 않도록 노력해야 합니다. 간단하게 말하자면, 개발자들의 생산성을 높이기 위해서는 주변 팀에서 장애나 산만함을 제거해서 개발자가 제대로 된 코드를 작성해 가치를 창출하는데 집중할 수 있어야 한다는 것입니다.</p>
<p>개발자에서 개발팀장이 된다는 것은 더 이상 생산자의 역할이 아니라 전체적인 영향을 극대화하는 역할로 바뀐다는 것입니다. 물론, 장애물과 방해자들을 제거하는 일도 포함해서요.</p>
<p>이런 것들을 잘 이해하지 못한다면 다른 개발자들과 같이 코딩하는데 시간을 쓸 수 없는 현실에 정말 큰 스트레스를 받게 됩니다. 너무 많은 회의에 좌절하거나 특정 시간에만 미팅을 하려고 하기도 하죠(코어 코딩/페어링 시간을 정해서). 극단적인 경우에는 기술과 관련 없는 모든 활동을 거부하는 행위를 보이기도 합니다(이해 관계자를 만나야 한다거나 하는). 이런 일련의 행동은 개발 리더가 다른 사람의 가치를 극대화하는 사람이 아니라 직접 개발을 해야 한다는 인식에 기인합니다.</p>
<p>제 경우에는, 저 자신을 팀의 핵심적인, 대체할 수 없는 역할로 여기기까지 했습니다. 다른 사람들도 이렇게 하는 것을 자주 봤는데요, 팀장과 팀원 사이의 기술적 역량 차이가 큰 작은 규모의 팀에서 특히 심했습니다. 개발을 해야 한다는 압박감에 다른 책임감까지 더해져 짓눌리는 상황에서 기술 리더들은 자신이 직접 개발하지 않으면 팀의 생산성이 떨어진다고 여기게 됩니다.</p>
<h2 id="5">4: 다른 사람에게 위임해야 할 때 모든 것을 알고 제어하려고 했다.</h2>
<p>어느 날, 회의에서 다른 팀장이 저에게 버그에 관해 물었습니다. 제가 손 댄 적이 없는 분야였기 때문에 답하기가 어려웠고, 노력하면 할수록 제 말의 설득력은 떨어졌습니다. 모른다는 것을 인정하기가 어려워 경험에 따라 적당히 답을 해버렸습니다. 다른 팀이 제 추측에 따라 애플리케이션을 변경하기 시작했고, 엄청난 시간을 낭비하고 나서야 제 추측이 틀렸음을 밝혀냈습니다. 저는 이런 실수가 무지에서 비롯되었다고 여기고, 아침마다 모든 커밋 로그를 읽기 시작했습니다.</p>
<p>커밋을 읽으면서, 절차적으로 작성된 코드의 특정 부분이 객체 지향적으로 바꾸면 좋겠다는 생각이 들었습니다. 다른 개발자 옆에 앉아서 다른 방법을 시도해보자고 얘기했고, 며칠 동안이나 코드의 작은 부분을 고치는 일에 빠져 있었습니다. 그러는 와중에 다른 팀원들은 큰 틀에서 설계를 변경하고 있었습니다. 그 변경 사항이 배포되고 나서 제가 눈치채지 못한 잘못된 가정 때문에 엄청난 버그를 일으키고 말았습니다.</p>
<p>저는 제 상관에게 어떤 일이 있었는지 솔직히 얘기했습니다. 제가 맡은 코드를 제대로 만드는 데 집중하느라 다른 부분에 신경 쓰지 못했다고요. 하지만 중요하지 않은 일에 신경 쓰고 있다는 질책을 이겨내기 어려웠습니다. 객체 지향적으로 코드를 작성하는 게 정말 중요했을까요? 그들의 반응은? 저는 선택을 해야 했습니다.</p>
<p>이런 일에는 공통점이 하나 있습니다. 모든 일에 개입할 수는 없다는 것입니다. 인간적으로 불가능합니다. 개발 리더로서 저는 책임감을 느끼고 다른 사람들을 믿고 중요한 것들에 더 집중해야 했습니다. 때로는 모른 체 해야 할 수도 있고, 제가 원하는 방식이나 이상적인 방법으로 진행되지 않아도 어쩔 수 없습니다. “나는 잘 모르겠고, 팀과 확인해봐야겠다.”고 얘기하는 게 잘못된 정보를 퍼트리는 것보다는 낫습니다. 절차적인 코드가 좀 있으면 어떻습니까. 오히려 제가 눈치채지 못한 큰 설계의 변경은 있을 수 없는 일입니다.</p>
<p>장기적인 관점에서 코드 수준을 높이기 위해서는, 문제가 생길 때마다 작은 문제를 고치는 데 노력을 기울이지 말고 멘토링과 코드 리뷰를 운영하는 것이 훨씬 효율적임을 깨달았습니다.</p>
<h2 id="6">5: 신호가 바뀐 걸 몰랐다</h2>
<p>프로젝트 회의에 참석하고, 개선을 제안해도 무언가 바뀌는 것이 없다고 생각되니 두려워지기 시작했습니다. 구체적인 제 성과가 보이지 않았습니다. 모든 단계에서 개발자들과 팀워크를 재고하는 방법들을 논의했습니다. 하지만 한 번 하고 난 다음에는 번번이 원래대로 돌아가기 일쑤였습니다. 다른 사람들은 개발자가 직접 데이터베이스를 다뤄야 한다고 생각하겠지만, 우리는 DBA가 스토어드 프로시저를 작성해줄 때까지 기다렸습니다. 개발자들에게 TDD를 하자고 해봤지만 한 번 하고 나서는 다들 손을 들었습니다. 말만 하고 아무것도 되질 않으니 겁이 나고 위축되었습니다.</p>
<p>매일 매일 기술만 생각하고 있다면, 당신은 피드백 과정과 일상적인 신호에 적응하게 됩니다. 우리는 일감 스토리보드의 일부로, 빌드가 통과되거나 프로덕션으로 릴리즈 될 때 엔도르핀을 방출합니다. 그리고 빌드가 깨지거나 새로운 스토리(이슈)가 생기면 코르티솔이 분비되어 ‘개발 중’ 상태에 빠집니다. 하지만 리더쉽을 요구하는 역할에서의 신호는 다른 곳에서 옵니다.</p>
<p>개발자가 신경 쓰는 것은 매일 매일 비슷하기 때문에 이러한 변화를 알아차리기가 어렵습니다. 스토리는 계속해서 만들어지고 전달되어야 하고 코드는 계속 작성되어야 합니다. 기술 팀장이 받는 신호는 여전히 기술적으로 여겨집니다.</p>
<p>리더쉽이 필요한 역할을 맡는다면 다른 신호들도 배우고 유심히 지켜봐야 합니다. 방향을 튼다면, 다른 사람에게 끼치는 영향이 있을 겁니다. 누가 아이디어를 이해했는지, 그리고 어떤 사람이 납득하고 누구를 설득하지 못했는지, 아니면 협조적인지 회의적인지에 대한 신호를 반드시 배워야 합니다. 다른 신호들도 많이 있는데, 이를테면 팀원이 업무에 지쳐 도움이 필요로 한다던가, 새로운 기술을 배우는데 적합한 도구가 없는 경우, 팀이 무엇을 목표로 해야 하는지 모르고 의사소통하는 문제들에 대해서요. 이런 신호들은 무언가 숨기거나, 다른 것을 강조하기도 하는 ‘사람’에게서 오기 때문에 알아차리기가 쉽지 않습니다.</p>
<blockquote><p>이런 신호를 알아차리는 것은 경험에 따른 육감에 가깝습니다. 이런 일에 익숙하지 않다면 전혀 모를 일이죠.</p>
</blockquote>
<p>그리고 이런 일들은 주의 깊게 다뤄져야 합니다. 항상 당신이 생각한 일 때문에 일어나는 것은 아니라서요.</p>
<p>정말 좋은 리더가 되려거든 이런 모든 신호에 귀 기울이고 그것들을 어떻게 이해하고 답을 줄지 고민해야 합니다. 찻잎이나 동물 내장을 통해 짐작하는 흑마법을 쓰는 주술사처럼 보일 수도 있고, 기술만큼 확실하지는 않겠지만 합리적으로 접근하여 배울 수 있는 일입니다.</p>
<h2 id="7">개발자 출신으로 성장하기</h2>
<p>이미 눈치채셨겠지만, 각 실수들은 서로 연관되어 있습니다. 예를 들어, 자신이 리더인 이유가 기술적인 면이 뛰어나서라고 생각한다면, 자기 자신을 생산자로 여기는 것을 피할 수 없을 겁니다. 그러다 보니 새로운 기술을 배우기가 더 어렵죠. 이런 실수들이 서로 꼬이고 꼬인 제 첫 팀장 경험은 완전히 망해버렸습니다.</p>
<p>리더쉽 역할을 맡게 된다는 건 큰 변화이고 벅찰 수 있습니다. 하지만 인간으로서, 고생한 만큼 새로운 능력을 발견할 수도 있습니다. 기술은 리더쉽의 근간이 되어야 하지만, 다른 부분에서 능력을 성장시켜야만 합니다. 이런 능력들이 사람과 함께 일하고, 의사소통하고, 납득시키고 설명하는 능력이든, 아니면 빠르게 습득하고, 새로운 걸 발견하고, 복잡한 문제의 원인을 찾거나 추상화 능력을 발전시켜 문제를 이해하기 쉽게 재구성하는 기술적인 능력이든 간에 말이죠. 제 능력에 자신감이 붙고 나서는 새로운 기술을 배울 수 있는 기회를 찾아, 흥미진진한 새로운 영역을 배우고 개발하는 것으로 뻗어 나갈 수 있었습니다.</p>
<p>리더쉽이 선형적으로 발전하는 게 아니라는 것을 이해하는 것이 중요합니다.</p>
<blockquote><p>팀장을 맡았다가 다시 순수한 개발자로 돌아가도 좋습니다. 더 나은 개발자로 만들어줄 기회가 될 것입니다. 뻔한 얘기지만, 리더쉽은 ‘팀장’ 딱지를 달아야만 생기는 건 아니니까요.</p>
</blockquote>
<p>팀은 자기계발을 위한 작은 기회들을 마련해서, 리더 역할을 맡지 않더라도 더 나은, 안전한 환경에서 다른 능력을 연습하고 배울 수 있는 방법을 찾아야만 합니다.</p>
]]></description>
    <pubDate>Tue, 04 Sep 2018 05:32:23 +0000</pubDate>
    
    <author>ez.amiryo@gmail.com (Park Hyunwoo)</author>
    
    <author>sunnybenlim@gmail.com (Sungbin Lim)</author>
    
    <author>cyberuls@gmail.com (jinho park)</author>
    
    <author>aiatejin@gmail.com (Jeen Lee)</author>
    
  </item>
  
  <item>
    <title>Why not join the sprints this year at PyCon</title>
    <link>https://muchtrans.com/translations/why-not-join-sprints-this-year-at-pycon.ko.html</link>
    <description><![CDATA[<h1 id="1">올해는 파이콘 스프린트에 참여해보시지 않겠습니까?</h1>
<p><a href="https://www.blogger.com/profile/09984149935314850807" title="author profile"> Naomi Ceder </a> 작성</p><p>
<a href="https://pycon.blogspot.com/2016/03/why-not-join-sprints-this-year-at-pycon.html" title="permanent link"> March 10, 2016  </a></p>
<p>파이콘에서 스프린트는 늘 숨겨진 보석과 같은 존재였습니다. 파이콘이 처음 열린 2003년부터 그래왔습니다. 컨퍼런스가 끝나고 며칠 뒤에 수백 명의 프로그래머가 모여 작고 큰 오픈소스 프로젝트들을 위해 협업합니다. 한 번이라도 참가해본 사람들은 그 경험을 귀중히 여깁니다. 스프린트에 참가하는 사람들은 프로젝트를 진행하며 참신한 시각과 아이디어를 얻는 것에 그치지 않고, 특정한 문제나 라이브러리, 파이썬 언어, 또는 일반적인 코딩에 대해 엄청난 인사이트를 찾아가게 됩니다. 올해도 예외 없이 잘 알려진 많은 프로젝트와 새롭게 참여하는 프로젝트들이 함께할 예정입니다.</p>
<p>이렇게 훌륭한 스프린트에 왜 더 많은 사람들이 파이콘 스프린트에 참여하지 않는지 의문이었습니다. 왜 그런 걸까요? 참석을 하고 말고에는 아마도 각자의 이유가 있겠지요. 하지만 아래 사항들에 대해서는 꼭 말씀드리고 명확하게 하고 싶습니다.</p>
<h2 id="2">파이콘 스프린트에 참가하지 않는 이유 (이럴 이유가 없죠)</h2>
<h3 id="3">아직 경험이 부족해서요.</h3>
<p>확실하게 답해드릴 수 있습니다! 모두가 스프린트를 해봤던 건 아니닌, 저희가 도와드릴께요. 이런 방법들로요.</p>
<ul>
<li><strong>“스프린트 소개” 워크샵을 스프린트가 시작하기 전, 일요일 밤에 개최할 예정입니다.</strong> Shauna Gordon-McKeon과 파이썬 커뮤니티의 여러 자원봉사자들이 여러분에게 도움을 드릴겁니다. 스프린트가 어떤 것인지, 어떻게 참여해야 하는지, 그리고 어떤 프로젝트가 새로운 참가자들에게 더 열려있는 지에 대해서요. 그리고 나선 모여서 저녁을 먹으러 갈텐데, 거기서 스프린트 리더들과 스프린트 참가자들을 만나 친해질 수 있을 겁니다. 이 워크샵에 관심이 있으시다면 <del>등록 페이지에서 등록해주세요.</del> (올해의 스프린트에 대해서는 <a href="https://us.pycon.org/">https://us.pycon.org/</a> 에 방문해서 알아보실 수 있습니다)</li>
<li><strong>새로운 참가자들을 환영하는 스프린트를 확인해드릴게요.</strong>, 그리고  새로운 참가자들을 잘 맞이하기 위해 스프린트 리더들에게 최대한 도움을 드릴 예정입니다.</li>
<li><strong>마지막으로, 뭐든지 도와드릴 수 있는 도움 창구를 마련해두겠습니다.</strong> 스프린트 진행에 필요한 공용 도구들을 설치하고 사용하는 방법이나, 어떻게 진행되고 있는지 같이 얘기 나눌 수 있도록 도와드리겠습니다.</li>
</ul>
<h3 id="4">어떤 스프린트에 참여해야할 지 몰라서요.</h3>
<p>네, 이해할 수 있습니다. — 흥미로워 보이는 많은 스프린트 프로젝트 중에서 고르기란 쉽지 않겠죠. 하지만, 그래서 저희가 있는 것이니까요. 파이콘이 시작되기 전에 많은 스프린트가 파이콘 사이트에 등록이 됩니다. <a href="https://us.pycon.org/2016/community/sprints/">미리 알아볼 수</a> 있습니다. 그리고 파이콘의 메인 컨퍼런스의 마지막 행사로, 스프린트 준비위원들이 각자의 스프린트를 소개하는 자리가 있습니다. 다시 한번 말씀드리자면, 저희가 처음 참가하는 분들에게 특별히 친절한 프로젝트들을 알려드릴 테니 걱정하지 마세요.</p>
<h3 id="5">스프린트 참가자 중 아는 사람이 없어요.</h3>
<p>아마 그럴 겁니다 (놀랄지도 모르겠지만요). 하지만 스프린트가 멋진 이유는 첫 날 점심시간에 스프린트를 하는 사람들을 만나게 된다는 점입니다. 프로젝트 관리자들은 당신이 발표에서 봤던 사람이고, 온라인에서라도 만난 적이 있는 사람입니다. 그리고 그들과 함께 개발하게 됩니다. 파이썬 커뮤니티의 새로운 사람들과 만나는 멋진 방법 아닌가요!</p>
<h3 id="6">스프린트에 어떻게 등록해야 하는 지 모르겠는데요. 번거롭지 않나요?</h3>
<p>그게 바로 저희가 있어야 하는 이유입니다. 스프린트에 참가하기 위해 등록을 바꿀 필요가 없습니다. 별도의 등록 비용이 없는데다, 무료로 점심도 제공됩니다. 추가 숙박이나 다른 끼니는 직접 해결해야겠지만, 그것 뿐입니다.</p>
<p>스프린트를 하기 전 가장 먼저 해야할 일은 행사 기간동안 추가로 숙박할 곳을 구해야 하는 것입니다. 파이콘 등록 시스템을 통해 방을 예약하셨다면 pycon2016@cteusa.com 을 통해 등록 팀과 최대한 빨리 추가 숙박을 요청하세요. 스프린트와 해당 기간의 점심은 무료이니, 숙박과 다른 식사만 추가 지출하시면 됩니다.</p>
<p>이런 것들을 마무리 하셨다면 (비행 일정도 당연히 챙겨야겠죠), <del>스프린트 소개 튜토리얼을 여기서 등록해주세요</del> (올해의 스프린트 정보는 <a href="https://us.pycon.org/">https://us.pycon.org/</a> 에서 확인하세요). 역시 무료이니 등록하여 함께해 주세요.</p>
<h2 id="7">스프린트 숙련자들도 환영합니다!</h2>
<p>이런 것들을 이미 다 알고 계시죠? 스프린트를 해봤다면 얼마나 환상적인지 잘 알고 계실겁니다. 여러분을 잊지 않았으니, 걱정마세요. 스프린트를 새롭게 하고 새로 오신 분들 만큼이나 숙련자에게도 더 나은 것을 제공하기 위해 노력하고 있으니까요. 이를 위해 새로운 것을 더하거나 바꿀 예정입니다.</p>
<h2 id="8">자, 이제 스프린트를 계획해봅시다!</h2>
<p><a href="https://us.pycon.org/2016/community/sprints/">파이콘 스프린트 페이지</a>에서 스프린트를 계획중인 프로젝트들을 확인할 수 있으니, 관심 있는 분들은 <del>스프린트 워크샵에 등록해주세요</del>. (더 많은 정보는 <a href="https://us.pycon.org/">https://us.pycon.org/</a> 에서). 파이콘에서의 스프린트를 잘 준비해보아요!</p>
]]></description>
    <pubDate>Thu, 31 Jan 2019 10:10:53 +0000</pubDate>
    
    <author>ez.amiryo@gmail.com (Park Hyunwoo)</author>
    
  </item>
  
  <item>
    <title>Software disenchantment</title>
    <link>https://muchtrans.com/translations/software-disenchantment.ko.html</link>
    <description><![CDATA[<h1 id="1">소프트웨어에 환멸을 느낀다</h1>
<p>저는 15년간 프로그래밍을 해왔죠. 근데 요즘 이 세계에서는 효율과 간결함에 대한 추구, 그리고 제대로 만들려는 노오력이 거의 없는 것 같습니다? 이제까지 쌓아온 제 경력이나 IT 전반에 대해 우울해질 지경이에요.</p>
<p>Modern cars work, let’s say for the sake of argument, at 98% of what’s physically possible with the current engine design. Modern buildings use just enough material to fulfill their function and stay safe under the given conditions. All planes converged to the optimal size/form/load and basically look the same.</p>
<p>Only in software, it’s fine if a program runs at 1% or even 0.01% of the possible performance. Everybody just seems to be ok with it. People are often even proud about how much inefficient it is, as in “why should we worry, computers are fast enough”:</p>
<blockquote><p><a href="https://twitter.com/tveastman/status/1039002300600147968">@tveastman</a>: I have a Python program I run every day, it takes 1.5 seconds. I spent six hours re-writing it in rust, now it takes 0.06 seconds. That efficiency improvement means I’ll make my time back in 41 years, 24 days :-)</p>
</blockquote>
<p>You’ve probably heard this mantra: “programmer time is more expensive than computer time”. What it means basically is that we’re wasting computers at an unprecedented scale. Would you buy a car if it eats 100 liters per 100 kilometers? How about 1000 liters? With computers, we do that all the time.</p>
<p><a href="https://xkcd.com/2021/"><img src="http://tonsky.me/blog/disenchantment/software_development_2x.gif" alt=""></a></p>
<h2 id="2">Everything is unbearably slow</h2>
<p>Look around: our portable computers are thousands of times more powerful than the ones that brought man to the moon. Yet every other webpage struggles to maintain a smooth 60fps scroll on the latest top-of-the-line MacBook Pro. I can comfortably play games, watch 4K videos but not scroll web pages? How is it ok?</p>
<p>Google Inbox, a web app written by Google, running in Chrome browser also by Google, <a href="https://twitter.com/nikitonsky/statuses/968882438024941568">takes 13 seconds to open moderately-sized emails</a>:</p>
<p>It also animates empty white boxes instead of showing their content because it’s the only way anything can be animated on a webpage with decent performance. No, decent doesn’t mean 60fps, it’s rather “as fast as this web page could possibly go”. I’m dying to see web community answer when 120Hz displays become mainstream. Shit barely hits 60Hz already.</p>
<p>Windows 10 <a href="https://grumpy.website/post/0PeXr1S7N">takes 30 minutes to update</a>. What could it possibly be doing for that long? That much time is enough to fully format my SSD drive, download a fresh build and install it like 5 times in a row.</p>
<p><img src="http://tonsky.me/blog/disenchantment/windows_update.gif" alt=""></p>
<blockquote><p><a href="https://pavelfatin.com/typing-with-pleasure/">Pavel Fatin</a>: Typing in editor is a relatively simple process, so even 286 PCs were able to provide a rather fluid typing experience.</p>
</blockquote>
<p>Modern text editors have higher latency than 42-year-old Emacs. Text editors! What can be simpler? On each keystroke, all you have to do is update tiny rectangular region and modern text editors can’t do that in 16ms. It’s a lot of time. A LOT. A 3D game can fill the whole screen with hundreds of thousands (!!!) of polygons in the same 16ms and also process input, recalculate the world and dynamically load/unload resources. How come?</p>
<p>As a general trend, we’re not getting faster software with more features. We’re getting faster hardware that runs slower software with the same features. Everything works way below the possible speed. Ever wonder why your phone needs 30 to 60 seconds to boot? Why can’t it boot, say, in one second? There are no physical limitations to that. I would love to see that. I would love to see limits reached and explored, utilizing every last bit of performance we can get for something meaningful in a meaningful way.</p>
<h2 id="3">Everything is HUUUUGE</h2>
<p>And then there’s bloat. Web apps could open up to 10× faster if you just simply block all ads. Google begs everyone to stop shooting themselves in their feet with AMP initiative—a technology solution to a problem that doesn’t need any technology, just a little bit of common sense. If you remove bloat, the web becomes crazy fast. How smart do you have to be to understand that?</p>
<p>Android system with no apps <a href="https://grumpy.website/post/0Oz1lDOq5">takes almost 6 Gb</a>. Just think for a second how obscenely HUGE that number is. What’s in there, HD movies? I guess it’s basically code: kernel, drivers. Some string and resources too, sure, but those can’t be big. So, how many drivers do you need for a phone?</p>
<p><img src="http://tonsky.me/blog/disenchantment/android_storage.jpg" alt=""></p>
<p>Windows 95 was 30Mb. Today we have web pages heavier than that! Windows 10 is 4Gb, which is 133 times as big. But is it 133 times as superior? I mean, functionally they are basically the same. Yes, we have Cortana, but I doubt it takes 3970 Mb. But whatever Windows 10 is, is Android really 150% of that?</p>
<p>Google keyboard app routinely eats 150 Mb. Is an app that draws 30 keys on a screen really five times more complex than the whole Windows 95? Google app, which is basically just a package for Google Web Search, is 350 Mb! Google Play Services, which I do not use (I don’t buy books, music or videos there)—300 Mb that just sit there and which I’m unable to delete.</p>
<p><img src="http://tonsky.me/blog/disenchantment/apps_storage.gif" alt=""></p>
<p>All that leaves me around 1 Gb for my photos after I install all the essential (social, chats, maps, taxi, banks etc) apps. And that’s with no games and no music at all! Remember times when an OS, apps and all your data fit on a floppy?</p>
<p>Your desktop todo app is probably written in Electron and thus <a href="https://josephg.com/blog/electron-is-flash-for-the-desktop/">has userland driver for Xbox 360 controller in it</a>, can render 3d graphics and play audio and take photos with your web camera.</p>
<p><img src="http://tonsky.me/blog/disenchantment/slack_memory.jpg" alt=""></p>
<p>A simple text chat is notorious for its load speed and memory consumption. Yes, you really have to count Slack in as a resource-heavy application. I mean, chatroom and barebones text editor, those are supposed to be two of the less demanding apps in the whole world. Welcome to 2018.</p>
<p>At least it works, you might say. Well, bigger doesn’t imply better. Bigger means someone has lost control. Bigger means we don’t know what’s going on. Bigger means complexity tax, performance tax, reliability tax. This is not the norm and should not become the norm. Overweight apps should mean a red flag. They should mean run away scared.</p>
<h2 id="4">Everything rots</h2>
<p>16Gb Android phone was perfectly fine 3 years ago. Today with Android 8.1 it’s barely usable because each app has become at least twice as big <em>for no apparent reason</em>. There are no additional functions. They are not faster or more optimized. They don’t look different. They just…grow?</p>
<p>iPhone 4s was released with iOS 5, but can barely run iOS 9. And it’s not because iOS 9 is that much superior—it’s basically the same. But their new hardware is faster, so they made software slower. Don’t worry—you got exciting new capabilities like…running the same apps with the same speed! I dunno.</p>
<p>iOS 11 dropped support for 32-bit apps. That means if the developer isn’t around at the time of iOS 11 release or isn’t willing to go back and update a once-perfectly-fine app, chances are you won’t be seeing their app ever again.</p>
<blockquote><p>@<a href="https://twitter.com/jckarter/statuses/1017071794245623808">jckarter</a>: A DOS program can be made to run unmodified on pretty much any computer made since the 80s. A JavaScript app might break with tomorrow’s Chrome update</p>
</blockquote>
<p>Web pages working today <a href="http://tonsky.me/blog/chrome-intervention/">would not be compatible with any browser in 10 years time</a> (probably sooner).</p>
<p>“It takes all the running you can do, to keep in the same place”. But what’s the point? I might enjoy occasionally buying a new phone and new MacBook as much as the next guy, but to do so just to be able to run all the same apps which just became slower?</p>
<p>I think we can and should do better than that. Everyone is busy building stuff for right now, today, rarely for tomorrow. But it would be nice to also have stuff that lasts a little longer than that.</p>
<h2 id="5">Worse is better</h2>
<p>Nobody understands anything at this point. Neither they want to. We just throw barely baked shit out there, hope for the best and call it “startup wisdom”.</p>
<p>Web pages ask you to refresh if anything goes wrong. Who has time to figure out what happened?</p>
<p><img src="http://tonsky.me/blog/disenchantment/reload.jpg" alt=""></p>
<p>Any web app produces a constant stream of “random” JS errors in the wild, even on compatible browsers.</p>
<p>The whole webpage/SQL database architecture is built on a premise (hope, even) that nobody will touch your data while you look at the rendered webpage.</p>
<p>Most collaborative implementations are “best effort” and have many common-life scenarios in which they lose data. Ever seen this dialogue “which version to keep?” I mean, bar today is so low that your users would be happy to at least have a window like that.</p>
<p><img src="http://tonsky.me/blog/disenchantment/icloud_conflict.jpg" alt=""></p>
<p>And no, in my world app that says “I’m gonna destroy some of your work, but you get to choose which one” is not okay.</p>
<p>Linux kills random processes <em>by design</em>. And yet it’s the most popular server-side OS.</p>
<p>Every device I own fails regularly one way or another. My Dell monitor needs a hard reboot from time to time because there’s software in it. Airdrop? You’re lucky if it’ll detect your device, otherwise, what do I do? Bluetooth? Spec is so complex that devices <a href="https://thewirecutter.com/blog/understanding-bluetooth-pairing-problems/">won’t talk to each other</a> and <a href="http://time.com/4358533/bluetooth-fix-how/">periodic resets are the best way to go</a>.</p>
<p><img src="http://tonsky.me/blog/disenchantment/plz_connect.jpg" alt=""></p>
<p>And I’m not even touching <a href="https://twitter.com/internetofshit">Internet of Things</a>. It’s so far beyond the laughing point I’m not even sure what to add.</p>
<p>I want to take pride in my work. I want to deliver working, stable things. To do that, we need to understand what we are building, in and out, and that’s impossible to do in bloated, over-engineered systems.</p>
<h2 id="6">Programming is the same mess</h2>
<p>It just seems that nobody is interested in building quality, fast, efficient, lasting, foundational stuff anymore. Even when efficient solutions have been known for ages, we still struggle with the same problems: package management, build systems, compilers, language design, IDEs.</p>
<p>Build systems are inherently unreliable and periodically require full clean, even though all info for invalidation is there. Nothing stops us from making build process reliable, predictable and 100% reproducible. Just nobody thinks its important. NPM has stayed in “sometimes works” state for years.</p>
<blockquote><p><a href="https://twitter.com/przemyslawdabek/status/940547268729606145">@przemyslawdabek</a>: It seems to me that <code>rm -rf node_modules</code> is indispensable part of workflow when developing Node.js/JavaScript projects.</p>
</blockquote>
<p>And build times? Nobody thinks compiler that works minutes or even hours is a problem. What happened to “programmer’s time is more important”? Almost all compilers, pre- and post-processors add significant, sometimes disastrous time tax to your build without providing proportionally substantial benefits.</p>
<p><a href="https://xkcd.com/303/"><img src="http://tonsky.me/blog/disenchantment/compiling.gif" alt=""></a></p>
<p>You would expect programmers to make mostly rational decisions, yet sometimes they do the exact opposite of that. E.g. choosing Hadoop <a href="https://www.chrisstucchio.com/blog/2013/hadoop_hatred.html">even when it’s slower than running the same task on a single desktop</a>.</p>
<p>Machine learning and “AI” moved software to guessing in the times when most computers are not even reliable enough in the first place.</p>
<blockquote><p><a href="https://twitter.com/freetonik/status/1039826129190875136">@rakhim</a>: When an app or a service is described as “AI-powered” or “ML-based”, I read it as “unreliable, unpredictable, and impossible to reason about behavior”. I try to avoid “AI” because I want computers to be the opposite: reliable, predictable, reasonable.</p>
</blockquote>
<p>We put virtual machines inside Linux, and then we put Docker inside virtual machines, simply because nobody was able to clean up the mess that most programs, languages and their environment produce. We cover shit with blankets just not to deal with it. “Single binary” is still a HUGE selling point for Go, for example. No mess == success.</p>
<p><a href="https://xkcd.com/1987/"><img src="http://tonsky.me/blog/disenchantment/python_environment_2x.gif" alt=""></a></p>
<p>And dependencies? People easily add overengineered “full package solutions” to solve the simplest problems without considering their costs. And those dependencies bring other dependencies. You end up with a tree that is something in between of horror story (OMG so big and full of conflicts) and comedy (there’s no reason we include these, <a href="https://medium.com/@jdan/i-peeked-into-my-node-modules-directory-and-you-wont-believe-what-happened-next-b89f63d21558">yet here they are</a>):</p>
<p><img src="http://tonsky.me/blog/disenchantment/dependencies.gif" alt=""></p>
<p>Programs can’t work for years without reboots anymore. Sometimes <a href="https://docs.gitlab.com/ee/administration/operations/unicorn.html#unicorn-worker-killer">even days are too much to ask</a>. Random stuff happens and nobody knows why.</p>
<p>What’s worse, nobody has time to stop and figure out what happened. Why bother if you can always buy your way out of it. Spin another AWS instance. Restart process. Drop and restore the whole database. Write a watchdog that will restart your broken app every 20 minutes. Include same resources <a href="https://blog.timac.org/2017/0410-analysis-of-the-facebook-app-for-ios-v-87-0/">multiple times, zip and ship</a>. Move fast, don’t fix.</p>
<p>That is not engineering. That’s just lazy programming. Engineering is understanding performance, structure, limits of what you build, deeply. Combining poorly written stuff with more poorly written stuff goes strictly against that. To progress, we need to understand what and why are we doing.</p>
<h2 id="7">We’re stuck with it</h2>
<p>So everything is just a pile of barely working code added on top of previously written barely working code. It keeps growing in size and complexity, diminishing any chance for a change.</p>
<p>To have a healthy ecosystem you <em>need</em> to go back and revisit. You <em>need</em> to occasionally throw stuff away and replace it with better stuff.</p>
<p><img src="http://tonsky.me/blog/disenchantment/design_process.jpg" alt=""></p>
<p>But who has time for that? We haven’t seen new OS kernels in what, 25 years? It’s just too complex to simply rewrite by now. Browsers are so full of edge cases and historical precedents by now that nobody dares to write layout engine from scratch.</p>
<p>Today’s definition of progress is either throw more fuel into the fire:</p>
<blockquote><p><a href="https://twitter.com/sahrizv/status/1018184792611827712">@sahrizv</a>: 2014 - We must adopt #microservices to solve all problems with monoliths.</p><p>
2016 - We must adopt #docker to solve all problems with microservices.</p><p>
2018 - We must adopt #kubernetes to solve all problems with docker</p>
</blockquote>
<p>or reinventing the wheel:</p>
<blockquote><p><a href="https://twitter.com/dr_c0d3/status/1040092903052378112">@dr_c0d3</a>: 2000: Write 100s of lines of XML to “declaratively” configure your servlets and EJBs.</p><p>
2018: Write 100s of lines of YAML to “declaratively” configure your microservices.</p><p>
At least XML had schemas…</p>
</blockquote>
<p>We’re stuck with what we have, and nobody will ever save us.</p>
<h2 id="8">Business won’t care</h2>
<p>Neither will users. They are only learned to expect what we can provide. We (engineers) say every Android app takes 350 Mb? Ok, they’ll live with that. We say we can’t give them smooth scrolling? Ok, they’ll live with a phone that stutter. We say “if it doesn’t work, reboot”? They’ll reboot. After all, they have no choice.</p>
<p>There’s no competition either. Everybody is building the same slow, bloated, unreliable products. Occasional jump forward in quality does bring competitive advantage (iPhone/iOS vs other smartphones, Chrome vs other browsers) and forces everybody to regroup, but not for long.</p>
<p>So it’s our mission as engineers to show the world what’s possible with today’s computers in terms of performance, reliability, quality, usability. If we care, people will learn. And there’s nobody but us to show them that it’s very much possible. If only we care.</p>
<h2 id="9">It’s not all bad</h2>
<p>There are some bright spots indicating that improving over state-of-the-art is not impossible.</p>
<p>Work <a href="https://twitter.com/mjpt777">Martin Thompson</a> has being doing (<a href="https://github.com/LMAX-Exchange/disruptor">LMAX Disruptor</a>, <a href="https://github.com/real-logic/simple-binary-encoding">SBE</a>, <a href="https://github.com/real-logic/aeron">Aeron</a>) is impressive, refreshingly simple and efficient.</p>
<p><a href="https://github.com/google/xi-editor">Xi editor</a> by Raph Levien seems to be built with the right principles in mind.</p>
<p><a href="https://www.youtube.com/user/jblow888">Jonathan Blow</a> has a language he alone develops for his game that can compile 500k lines per second on his laptop. That’s cold compile, no intermediate caching, no incremental builds.</p>
<p>You don’t have to be a genius to write fast programs. There’s no magic trick. The only thing required is not building on top of a huge pile of crap that modern toolchain is.</p>
<h2 id="10">Better world manifesto</h2>
<p>I want to see progress. I want change. I want state-of-the-art in software engineering to improve, not just stand still. I don’t want to reinvent the same stuff over and over, less performant and more bloated each time. I want something to believe in, a worthy end goal, a future better than what we have today, and I want a community of engineers who share that vision.</p>
<p>What we have today is not progress. We barely meet business goals with poor tools applied over the top. We’re stuck in local optima and nobody wants to move out. It’s not even a good place, it’s bloated and inefficient. We just somehow got used to it.</p>
<p>So I want to call it out: where we are today is bullshit. As engineers, we can, and should, and will do better. We can have better tools, we can build better apps, faster, more predictable, more reliable, using fewer resources (orders of magnitude fewer!). We need to understand deeply what are we doing and why. We need to deliver: reliably, predictably, with topmost quality. We can—and should–take pride in our work. Not just “given what we had…”—no buts!</p>
<p>I hope I’m not alone at this. I hope there are people out there who want to do the same. I’d appreciate if we at least start talking about how absurdly bad our current situation in the software industry is. And then we maybe figure out how to get out.</p>
]]></description>
    <pubDate>Thu, 27 Sep 2018 11:06:23 +0000</pubDate>
    
    <author>ez.amiryo@gmail.com (Park Hyunwoo)</author>
    
  </item>
  
  <item>
    <title>Becoming a 10x Developer</title>
    <link>https://muchtrans.com/translations/10xdeveloper.ko.html</link>
    <description><![CDATA[<h1 id="1">10배 뛰어난 개발자 되기</h1>
<h2 id="2">좋은 동료가 되기 위한 10가지 방법</h2>
<p>2018년 3월 12일</p>
<p>제가 수구를 처음 배울 때에, 코치가 해줬던 말이 잊혀지지 않습니다. 그는 “뛰어난 선수는 주변 선수들을 뛰어난 선수처럼 보이게 한다.” 라고 했습니다. 뛰어난 선수는 잘못된 던지기를 예상하고 미리 움직여 어떤 패스라도 잡을 수 있습니다. 뛰어난 선수가 공을 다시 패스할 때는 다른 사람이 쉽게 잡을 수 있도록 공을 던집니다.</p><p>
오늘날의 소프트웨어 개발은 팀 스포츠와 같습니다. 수구에서와 같이 뛰어난 소프트웨어 시스템은 혼자서 만들 수 없습니다. 그래서 처음 10배 뛰어난 엔지니어에 대한 컨셉을 들었을 때는 혼란스러웠습니다. 어떻게 한 명의 뛰어난 사람이 팀웍을 이길 수 있을까? 제 경험상 성공을 위해 각 개인의 뛰어남은 필수 요소지만, 충분 요소는 아니었습니다. 개개인의 업적에 초점을 맞추면 좋은 소프트웨어 개발을 위해 팀이 필요하다는 큰 그림을 못 보게 됩니다. 그래서 10배 뛰어난 엔지니어에 대한 정의를 이렇게 바꿔봤습니다.</p>
<blockquote><p>10배 뛰어난 엔지니어는 남들보다 10배 뛰어난 사람이 아니라, 주변 사람을 10배 뛰어나게 만드는 사람이다.</p>
</blockquote>
<p>수 년에 걸친 개인적인 경험과 효율적인 팀 구성과 발전에 대한 연구를 조합하여, 개개인의 경험과 무관하게 10배 나은 동료가 될 수 있는 방법을 목록으로 만들었습니다. 훌륭한 동료가 되기 위한 일반적인 조언들과 함께, 다양한 배경을 가진 사람들 속에서 어떻게 좋은 동료가 될 수 있는가에 중점을 두었습니다.</p>
<h2 id="3">더 나은 동료가 되기 위한 10가지 방법</h2>
<ul>
<li>정서적으로 안전한 환경 만들기</li>
<li>모두 동등하게 참여하도록 격려하기</li>
<li>공명정대하게 공로 나누기</li>
<li>회의에서 들리지 않는 목소리를 키우기</li>
<li>개인적인 비판이 아닌 건설적이고 실용적인 피드백</li>
<li>자기 자신과 타인에게 책임감 가지기</li>
<li>팀에 가치있는 분야에 투자하기</li>
<li>직장내 다양성, 포괄성 그리고 동등함에 대해 배우기</li>
<li>성장에 대한 마음가짐 유지하기</li>
<li>직장내 평등에 대한 회사 정책에 소리내기</li>
</ul>
<h2 id="4">1. 정서적으로 안전한 환경 만들기</h2>
<p>2012년, 구글은 아리스토텔레스 프로젝트를 시작했습니다. 이는 구글 내의 많은 팀을 조사하여 몇몇 팀들이 왜 다른 팀보다 좋은 성과를 내는지 분석하는 프로젝트입니다 <sup class="footnote-ref" id="tfnref-1"><a href="#tfn-1">1</a></sup>. 이 연구는 팀의 생산성이 높고 낮음에 오직 두 가지 차이점만이 있음을 밝혀냈습니다. 그 중 하나는 연구자들이 정서적 안전함이라 부르는 요소였습니다. 하버드 비즈니스 스쿨의 Amy Edmondson 교수는 이것을 “팀내에서 대인 관계의 위험 감수를 할 필요가 없다는 구성원 사이에 공유되는 믿음” 즉, “발언에 대해 치욕스럽게 하거나, 거부하거나 처벌하지 않을 것이라는 확신” 이라고 설명합니다. 정서적 안전함을 갖춘 환경을 조성하는 것은 팀원들이 서로를 신뢰하고 업무에 대해 자유롭게 의견을 나눌 수 있는 공간을 만듭니다. 사무실에서 정서적으로 안전한 환경을 조성하는 몇 가지 방법이 있습니다.</p>
<ul>
<li>비판적이지 않은 방법으로 다른 사람의 아이디어와 감정을 인정해주세요. 인정은 판단하거나 평가내리는 것에서 분리되어야 합니다.</li>
<li>팀 동료의 의견에 “응, 그리고” 같은 자세로 답해 대화를 이어나가 주세요 (즉흥 연기와 같이 말이죠!) <sup class="footnote-ref" id="tfnref-2"><a href="#tfn-2">2</a></sup>.</li>
<li>의심스러워도, 믿어주세요. 당신이 믿을 때까지 그들로 하여금 증명하도록 하지 말고, 틀렸다고 밝혀지기 전까지는 일단 동료를 믿어주세요.</li>
</ul>
<h2 id="5">2. 모두 동등하게 참여하도록 격려하기</h2>
<p>아리스토텔레스 프로젝트에서 밝혀낸 생산적인 팀을 구성하는 두 번째 요소는 – 학술적으로 말하자면 – ‘균등 분배된 발언권’ 현상입니다. 기본적으로, 효율적인 팀에 속한 사람들은 동등하게 참여한다는 뜻입니다. 모든 구성원이 매 회의마다 동등하게 말해야한다는 것을 의미하는게 아니라, 시간이 지남에 따라 팀원 개개인이 동등하게 기여해야 한다는 것입니다. 그렇다면 팀원 개개인이 동등하게 기여하는 팀 문화를 어떻게 조성할 수 있을까요?</p>
<ul>
<li>회의시간에 동료에게 의견을 물어보세요.</li>
<li>“내 생각엔” 그리고 “아마도” 같은 표현으로 토론을 시작해보세요. (저는 이것을 ‘여성스럽게 말하면 어떨까?’ 화법으로 부릅니다)</li>
<li>편하게 자주 얘기하세요 <sup class="footnote-ref" id="tfnref-3"><a href="#tfn-3">3</a></sup>.</li>
<li>혼자 떠들고 있는 사람이 있으면 알려주고, 모두가 말할 수 있는 분위기를 만들어주세요.</li>
</ul>
<h2 id="6">3. 공명정대하게 공로 나누기</h2>
<p>업무에 대한 공로를 정확하게 분배하는 것은 팀과 조직 내에 신뢰를 형성하는데 매우 중요한 일입니다 <sup class="footnote-ref" id="tfnref-4"><a href="#tfn-4">4</a></sup>. 우리들 중 많은 이들이 자신의 작업에 대해 제대로 인정받지 못하거나, 엉뚱한 사람이 공을 가져간 경험이 있을겁니다.</p><p>
공로를 인정하는 일은 그 사람을 뛰어나 보이게 만드는 것뿐 아니라, 인정하는 사람도 같이 좋아보이게 합니다. 다른 사람들을 인정하는 사람들은 그렇지 않은 사람이 비해 더 똑똑해 보이고 호감이 갑니다. 서로 윈–윈 하는 일이기 때문에 동료를 칭찬하지 않을 이유가 없습니다.</p><p>
다른 사람의 공로를 인정하는 문화를 만들기 위해서는 어떤 노력이 필요할까요?</p>
<ul>
<li>프로젝트가 끝날때 마다 당신을 도와준 사람들에게 감사를 전하세요.</li>
<li>조용하거나 스스로 동기 부여가 잘 되지 않는 사람들, 의욕이 없는 사람들에게 주목하세요.</li>
<li>누군가를 칭찬하고 공로를 인정할 때, 정직하고 구체적이며 진실되게 전하세요.</li>
</ul>
<h2 id="7">4. 회의에서 들리지 않는 목소리를 키우기</h2>
<p>2009년, 오바마 대통령의 여성 스태프 그룹이 함께 ‘증폭’이라는 전략을 만들었습니다 <sup class="footnote-ref" id="tfnref-5"><a href="#tfn-5">5</a></sup>. 그들은 남성 중심적인 사무 환경에서 여성들이 겪는 여러 어려움에 직면해 있었습니다. 여성들이 중요한 회의에 참석하는 동안 그들은 간과되거나 소외되는 문제가 있었습니다. 그래서 그들은 목소리를 서로 증폭하기로 했습니다. 여성 스태프가 핵심 아이디어를 만들면 다른 여성들이 그것을 반복하고 계속해서 원 저자를 알려, 그 아이디어가 누구에게서 나온 것인지 알아차릴 수 밖에 없도록 합니다. 오바마 대통령은 이 사실을 알고, 여성 스태프들에 더 많은 기회를 주도록 했습니다. 그의 두 번째 임기에는 성별이 더 동등하게 나뉘었으며, 부서 중 절반은 여성이 이끌게 되었습니다.</p><p>
이 일은 매우 단순하지만, 누구나 동료를 위해 할 수 있는 시행할 수 있는 구체적인 방법입니다. 소외되거나 간과되는 사람에게 귀기울여, 그들의 목소리를 증폭시켜주세요. 여성들이 자주 말하게 되는 것이 일상이 되어도 <sup class="footnote-ref" id="tfnref-6"><a href="#tfn-6">6</a></sup>, 부드럽게 말하거나 수줍어 하는 사람, 내성적인 사람에게도 일어날 수 있는 일입니다.</p>
<h2 id="8">5. 개인적인 비판이 아닌 건설적이고 실용적인 피드백</h2>
<p>비판받는 것을 싫어하는 것은 매우 일반적인 일이고, 신중하지 못하거나 건설적이지 않은 비판은 사람들의 생산성마저 깎아내릴 수 있습니다 <sup class="footnote-ref" id="tfnref-8"><a href="#tfn-8">7</a></sup>. 앞서 얘기했던 것과 같이 당신의 피드백이 사려깊고 건설적인지 아닌지가 좋은 동료가 되는데 있어 정말로 중요합니다. 뿐만 아니라, 피드백은 편향을 불러올 수 있으므로, 피드백을 잘 전달하는 것에 대한 학습은 다양한 팀에게 있어 아무리 시간을 들여도 아깝지 않은 일입니다.</p><p>
예를 들면, 여성들이 받는 비난이나 조롱을 남성들은 받지 않는다는 것은 누구나 알고 있습니다. 여성들은 ‘된장녀’, ‘뻔뻔한’, ‘공격적’ 같은 이야기를 남성에 비해 많이 듣습니다. 2014년에 Textio의 설립자이자 CEO인 Kieran Snyder는 이 일이 사실인지 확인하고자 했습니다 <sup class="footnote-ref" id="tfnref-7"><a href="#tfn-7">8</a></sup>. 남성 105명과 여성 75명, 총 180명으로부터 248개의 리뷰를 수집하고 내용을 분석했습니다. 그게 사실이라는 것을 이미 알고 있음에도 놀라울만한 결과가 나왔습니다. 87.9%의 여성이 조롱이나 부정적인 피드백을 받았는데, 남성의 경우 58.9%에 불과했습니다. 내용을 따지고 보면 이 차이는 더 심해집니다. 76%의 여성이 업무 외의 개인적인 부분에서 비난을 받는 동안 2%의 남성만이 그러한 비난을 받았습니다.</p><p>
더 나은 피드백을 주기 위한 다음의 방법을 제안합니다.</p>
<ul>
<li>피드백을 받을 수 있는 상황인지 먼저 물어보세요.</li>
<li>그 사람의 업무적인 부분에만 초점을 두고 피드백하세요.</li>
<li>어떻게 하면 더 개선할 수 있는지 얘기해주세요. 문제를 명확하게 하고 어떻게 하면 대상자가 개선할 수 있는지에 대한 생각을 얘기하세요.</li>
<li>개인적인 비난은 하지 마세요. 그런 부분에 대한 피드백이 정말 필요하다고 생각한다면, 관리자나 HR 담당자와 얘기하여 내용을 정리하고 검토하세요.</li>
</ul>
<h2 id="9">6. 자기 자신과 타인에게 책임감 가지기</h2>
<p>얼마 전에 대학시절 축구 선수로 활동했던 친구 James를 만났습니다. 그는 지금 한 스타트업의 COO로 있는데, 그가 말하길 많은 시간을 직원들에게 기본적인 팀웍에 해당하는 것을 가르치는데 쓴다고 합니다. 책임감에 관한 것에 중점을 두고요. 예전 일을 생각해보면, James는 수백 수천 시간을 좋은 팀원이 되기 위해 연습하는데 썼습니다. 팀으로 잘 굴러가기 위한 일들이 그에게는 명확하게 보이겠지만, 다른 사람들에게는 – 특히 책임감에 관해서라면 – 명확하지 않을 수 있습니다. 축구는 강한 책임감이 필요한 운동이고, 선수들에게 서로 책임을 지게하기 위해서는 시간을 들여 연습하는 것 외에 긍정적인 태도, 팀원을 독려하는 일, 그리고 유능함에 대한 높은 기준을 유지하는 방법이 있습니다. 자기 자신과 동료 모두가 책임감을 높이기 위해서는 이런 방법을 사용해보세요.</p>
<ul>
<li>일을 가능한한 제 시간안에 할 수 있도록 합니다 (엔지니어들에게 이게 참 어려운 일인건 알지만, 작은 프로젝트부터 정확성을 높여 나간다면 책임감 향상에 도움이 될겁니다).</li>
<li>Jeff Lawson이 창업자들에게 가장 중요하다고 말하는 것은 “한다고 말했던 일을 해라” 입니다. <span>(역주: Jeff Lawson은 Twilio의 창업자)</span></li>
<li>다른 사람을 돕다 보면, 다른 사람에게 도움을 구하기도 합니다.</li>
<li>큰 프로젝트나 이슈에 대해서 팀의 일이 끝날 때까지 함께합니다 <sup class="footnote-ref" id="tfnref-9"><a href="#tfn-9">9</a></sup> (실제로 남아도 좋고, Slack 같은 원격 도구라도 좋습니다).</li>
</ul>
<h2 id="10">7. 팀에 가치있는 분야에 투자하기</h2>
<p>10배 뛰어난 엔지니어 되기에 대해 얘기하면 사람들은 흔히 다른 사람보다 뛰어난 것으로 받아들입니다. 개인적인 역량이 뛰어난 것은 좋은 동료가 되기에 필수 요소일 뿐이고, 결국 팀을 위해서 뭔가 해야합니다. 어떤 분야에 뛰어난 사람이 되려고 한다면, 그 분야는 당신에게 진정한 동기부여가 가능한 것이어야 합니다. 당신에게 에너지를 주는 일이면서 동시에 현재 보유한 능력과 관심사와도 맞아야겠죠. 개인 지식 기반이 점점 더 전문화되고 있기 때문에, 뛰어난 사람이 되기 위해서는 정말 많은 시간과 에너지를 투자해야 합니다 <sup class="footnote-ref" id="tfnref-10"><a href="#tfn-10">10</a></sup>. 잠깐으로 되는 일이 아니기 때문에 진정 즐길 수 있는 일이어야 합니다. 자기 계발/개발에 대한 이 사회의 관심이 큰 것으로 알고 있으니, 해당 분야에 대해서는 도서나 블로그 등을 통해 발전시키는 것도 좋겠습니다.</p>
<h2 id="11">8. 직장내 다양성, 포괄성 그리고 동등함에 대해 배우기</h2>
<p>다양성과 포괄성은 팀 스포츠와 같이, 모든 직급의 모든 사람이 함께 해야합니다. 좋은 동료가 되기 위한 최고의 방법 중 하나는 성차별과 인종 차별이 직장에서 어떻게 이뤄지고 있는지 스스로 학습하는 것입니다. 프로그래밍 언어와 툴 사용법을 익히는 것만큼이나 평등한 작업 환경을 구성하는 것에 대한 글과 연구에 관심을 가지고 따라잡는 일도 중요합니다.</p><p>
“깨우친 남성의 뒤에는 항상 페미니스트가 있다”라는 농담이 있는데, 아마 깨우친 백인들도 유색 인종들이 받은 핍박 속에서 태어났을 겁니다. 이제 바꿉시다. 누구나 읽고 연구할 수 있는 시대입니다.</p>
<ul>
<li>모든 것을 읽으세요.</li>
<li>사람들에게 읽기를 권유하거나 메일링 리스트에 가입하라 하세요.</li>
<li>최대한 많이 들으세요.</li>
<li>당신의 의견은 교육받은 만큼 그 가치가 올라갑니다. 그러니 스스로 깨우치지 못하면 당신의 의견은 별 의미가 없습니다.</li>
</ul>
<h2 id="12">9. 성장에 대한 마음가짐 유지하기</h2>
<p>30년 전에, 심리학자 Carol Dweck은 실패로부터의 추진력에 관심을 가졌습니다 <sup class="footnote-ref" id="tfnref-11"><a href="#tfn-11">11</a></sup>. 그녀와 그녀의 연구팀은 학생들이 작은 실수로도 무너지는 반면, 실패로부터 회복하는 학생들도 있음을 알게되었습니다. 그 이유가 궁금했습니다. 수 천명의 아이들을 연구한 결과, ‘성장하고자 하는 마음가짐’이라는 용어를 얻어냈습니다. 이는 능력과 지능을 발전시킬 수 있다는 믿음을 의미합니다. 이런 마음가짐이 있는 학생들은 실패에서도 배워 능력과 지능을 키울수 있다는 믿음이 있는데, 지능은 발전되지 않는다고 믿는 학생들이 작은 실수로도 무너지는 것과 비교가 됩니다.</p>
<ul>
<li>주어진 시간과 노력, 인터넷으로 무엇이든 배울수 있음을 명심하세요.</li>
<li>어떻게 발전할 수 있었는가에 대한 피드백을 준비하세요.</li>
<li>결승선이 없는 일입니다. 좋은 엔지니어와 동료가 되는 것은 평생, 매일의 수련입니다.</li>
</ul>
<h2 id="13">10. 직장내 평등에 대한 회사 정책에 소리내기</h2>
<p>마지막으로, 팀의 모든 동료를 위해 더 평등하고 포괄적인 업무 환경을 조성할 수 있다고 생각하는 것을 얘기하세요. 조직 내에서 어떤 위치에 있더라도 작업 환경을 개선하는 정책에 대해서는 지지할 수 있습니다. 8번에서 얘기한 것들을 읽고 연구한다면 더 쉽게 진행할 수 있습니다. 검증된 조직적인 변화의 예를 몇 가지 들어보겠습니다.</p>
<ul>
<li>The Rooney Rule: 중요한 직책을 채용할 때, 소수 인종을 반드시 한 명 이상 후보에 넣어야 합니다 <sup class="footnote-ref" id="tfnref-12"><a href="#tfn-12">12</a></sup>.</li>
<li>승진 대상 후보자 평가는 혼자가 아닌 단체로 해야합니다. <sup class="footnote-ref" id="tfnref-13"><a href="#tfn-13">13</a></sup></li>
<li>회의, 급여, 계획과 같은 내부 절차의 투명성을 만들어가야 합니다.</li>
</ul>
<h2 id="14">맺음말</h2>
<p>수구 선수 생활을 그만둔 뒤에 코치 생활을 시작했고, 가르쳤던 아이들에게 항상 얘기했던 하나는 이것입니다. 승률은 개인의 재능 합에 팀으로 얼마나 잘하는가를 곱한 것이라고요.</p>
<blockquote><p>승률 = Σ(재능) * 팀웍</p>
</blockquote>
<p>일하는 것에 적용한다면, 수식은 이렇게 됩니다.</p>
<blockquote><p>생산성 = Σ(재능) * 팀웍</p>
</blockquote>
<p>팀웍이 강한 팀은 개개인의 능력이 더 뛰어난 팀보다 더 뛰어날 수 있습니다. 이런 일들을 스포츠와 기술업계, 사회에서 수도 없이 보아왔습니다. 소규모 팀이라도 팀으로써 잘 기능할 때, 엄청난 소프트웨어를 만들어내는 일은 결코 우연이 아닙니다. 자, 그러니 개인적으로 우수해지는 것 외에, 제 코치가 저에게 말해준 것처럼, 진정한 뛰어남은 당신이 얼마나 대단한 사람이냐가 아니라 당신 주변을 얼마나 대단하게 만드느냐에서 온다는 것을 잊지 않길 바랍니다.</p>
<div class="footnotes">
<hr>
<ol><li id="tfn-1"><p>Duhigg, Charles. <a href="https://www.nytimes.com/2016/02/28/magazine/what-google-learned-from-its-quest-to-build-the-perfect-team.html">What Google Learned from its Quest to Build a Perfect Team</a>. NyTimes.com, 2016.<a href="#tfnref-1" class="footnote">&#8617;</a></p></li>
<li id="tfn-2"><p>Edge Studio. <a href="https://www.edgestudio.com/blogs/yes-and-how-improv-attitude-helps-many-ways">Yes and...How Improv Attitude Helps in Many Ways</a>. edgestudios.com, 2015.<a href="#tfnref-2" class="footnote">&#8617;</a></p></li>
<li id="tfn-3"><p>Pentland, Alex “Sandy”. <a href="https://hbr.org/2012/03/the-new-science-of-building-gr">The Hard Science of Teamwork</a>. Harvard Business Review, hbr.com, 2012.<a href="#tfnref-3" class="footnote">&#8617;</a></p></li>
<li id="tfn-4"><p>Jain, Sachin H. <a href="https://hbr.org/2014/03/the-importance-of-giving-credit">The Importance of Giving Credit. Harvard Business Review</a>, hbr.com, 2014.<a href="#tfnref-4" class="footnote">&#8617;</a></p></li>
<li id="tfn-5"><p>Landsbaum, Claire. <a href="https://www.thecut.com/2016/09/heres-how-obamas-female-staffers-made-their-voices-heard.html">Obama’s Female Staffers Came Up With a Genius Strategy to Make Sure Their Voices Were Heard</a>. The Cut, thecut.com, 2016.<a href="#tfnref-5" class="footnote">&#8617;</a></p></li>
<li id="tfn-6"><p>Chira, Susan. <a href="https://www.nytimes.com/2017/06/14/business/women-sexism-work-huffington-kamala-harris.html">The Universal Phenomenon of Men Interrupting Women</a>. NyTimes.com, 2017.<a href="#tfnref-6" class="footnote">&#8617;</a></p></li>
<li id="tfn-8"><p>Nass, Clifford; Yen, Corina (2010-09-02). <a href="https://www.amazon.com/Man-Who-Lied-His-Laptop-ebook/dp/B003YUC7BI/ref=tmm_kin_swatch_0?_encoding=UTF8&amp;amp;sr=1-1-catcorr&amp;amp;qid=1426406230">The Man Who Lied to His Laptop: What We Can Learn About Ourselves from Our Machines</a>. Penguin Group US. Kindle Edition.<a href="#tfnref-8" class="footnote">&#8617;</a></p></li>
<li id="tfn-7"><p>Snyder, Kieran. <a href="http://fortune.com/2014/08/26/performance-review-gender-bias/">The Abrasiveness Trap: High-achieving men and women are described differently in reviews</a>. Fortune.com, 2014.<a href="#tfnref-7" class="footnote">&#8617;</a></p></li>
<li id="tfn-9"><p>Gleeson, Brent. <a href="https://www.forbes.com/forbes/welcome/?toURL=https://www.forbes.com/sites/brentgleeson/2016/12/08/why-accountability-is-critical-for-achieving-winning-results">Why Accountability is Critical</a>. Forbes.com, 2016.<a href="#tfnref-9" class="footnote">&#8617;</a></p></li>
<li id="tfn-10"><p>Jones, Benjamin F. <a href="https://insight.kellogg.northwestern.edu/article/the-science-behind-the-growing-importance-of-collaboration">The Science Behind the Growing Importance of Collaboration. Kellog Insight</a>, insight.kellog.northwestern.edu, 2017.<a href="#tfnref-10" class="footnote">&#8617;</a></p></li>
<li id="tfn-11"><p>Dweck, Carol S. Mindset: <a href="https://www.amazon.com/Mindset-Psychology-Carol-S-Dweck/dp/0345472322">The New Psychology of Success</a>. Ballantine Books, 2006.<a href="#tfnref-11" class="footnote">&#8617;</a></p></li>
<li id="tfn-12"><p><a href="https://en.wikipedia.org/wiki/Rooney_Rule">The Rooney Rule</a>. Wikipedia. Wikipedia.org, 18 March, 2018.<a href="#tfnref-12" class="footnote">&#8617;</a></p></li>
<li id="tfn-13"><p>Starvish, Maggie. <a href="https://hbswk.hbs.edu/item/better-by-the-bunch-evaluating-job-candidates-in-groups">Better by the Bunch: Evaluating Job Candidates in Groups</a>. Harvard Business School, hbswk.hbs.com, 2012.<a href="#tfnref-13" class="footnote">&#8617;</a></p></li>
</ol>
</div>
]]></description>
    <pubDate>Thu, 16 Aug 2018 09:03:23 +0000</pubDate>
    
    <author>ez.amiryo@gmail.com (Park Hyunwoo)</author>
    
  </item>
  
  <item>
    <title>Tim Cook's memo at AAPL hits $1 trillion market cap</title>
    <link>https://muchtrans.com/translations/timcook-letter-1t.ko.html</link>
    <description><![CDATA[<h1 id="1">애플 시가 총액 1조 달러 도달에 팀 쿡이 사내에 전한 감사 메세지</h1>
<p>여러분,</p>
<p>오늘 애플은 의미 있는 지점을 넘어섰습니다. 애플 주식은 207.39달러의 가격으로 마감되었으며, 애플의 시가 총액은 1조 달러 이상에 도달했습니다. 이는 매우 자랑스러운 우리의 성과이지만, 성공을 가늠하는데 가장 중요한 척도는 아닙니다. 재무적인 성과는 애플의 혁신, 제품과 고객을 최우선시하는 것, 그리고 우리의 주요 가치에 집중하는 일에 따른 결과일 뿐입니다. <sup>역주: 1조 달러 ≈ 1천조 원 이상</sup></p>
<p>당신이, 우리가 애플을 성장시켰고, 오늘날의 성공은 당신의 근면, 헌신, 열정 덕분입니다. 여러분의 업무와 성과에 항상 겸손해질 따름이며, 당신과 함께 일하는 것은 제 일생의 더할 나위 없는 영광입니다. 함께 일하는 데 있어, 언제나 탁월함에 도달하기 위한 많은 시간과 여정에 진심으로, 정말 가슴 깊은 곳에서 감사의 마음을 전하고 싶습니다.</p>
<p>이 자리를 빌려 고객, 공급 업체, 협력 업체, 애플 개발자 커뮤니티, 우리 동료들, 그리고 이 놀라운 회사를 거쳐 간 모든 이들에게 감사드립니다.</p>
<p>스티브는 사람의 창의력이 가진 힘으로 그 어떤 어려운 도전도 이겨낼 수 있다는 믿음으로 애플을 설립했습니다 – 그리고 세상을 바꿀 수 있다고 생각하는 미친 사람들이 모여 그 일을 해내고 있습니다. 오늘날, 우리의 사명은 그 무엇보다 중요합니다. 우리의 제품은 놀랍고 즐거운 순간을 만드는 것에 그치지 않고, 온 세상 사람들이 주변 사람들과 함께 풍요로운 삶을 만들 수 있도록 합니다.</p>
<p>스티브가 이런 순간에 항상 그러했듯, 우리는 애플의 밝은 미래와 우리가 함께 해나갈 위대한 일들을 기대합니다.</p>
<p>팀</p>
]]></description>
    <pubDate>Thu, 16 Aug 2018 09:03:23 +0000</pubDate>
    
    <author>ez.amiryo@gmail.com (Park Hyunwoo)</author>
    
  </item>
  
  <item>
    <title>Ryuichi Sakamoto – “We are destroying the world.”</title>
    <link>https://muchtrans.com/translations/ryuichi-sakamoto-52-insights.ko.html</link>
    <description><![CDATA[<h1 id="1">류이치 사카모토 – "우리는 세상을 파괴하고 있다."</h1>
<h2 id="2">선구적인 일본 음악가 류이치 사카모토를 다룬 다큐멘터리 Coda에서 그는 후두암으로 고생하며, 아카데미상 후보에 오른 레버넌트의 사운드트랙 작업을 하며 스스로의 작곡 능력에 의문을 품는 장면이 나옵니다. 예술이 어떻게 인생을 반영할 수 있는가에 대한 잊혀지지 않는 잔영으로 남습니다.</h2>
<p>이는 류이치가 세상을 보는 방식과도 같습니다. 그는 예술가들이 우리 시대의 문제에 항상 촉을 세워야 한다는 점에서 석탄 광산의 카나리아와 같다고 얘기합니다.</p>
<p>류이치는 이 일을 두 언어로 합니다. 엄청나게 섬세한 음악을 통해서, 또 환경에 끼치는 인류의 재앙적인 영향에 대해서 목소리로 얘기해왔습니다.</p><p>
이 영화에서 흔들리는 그의 양심을 자주 볼 수 있습니다. 후쿠시마 원자로의 피해를 조사하고, 남극 대륙으로 가는 배에 올라 생태계의 취약함을 직접 보러 가기도 합니다.</p>
<p>음악 분야에서 가장 깊이 있는 개척자중 한 사람인 그는, 동시대 사람이자 같이 연기하기도 했던 데이빗 보위(David Bowie)의 죽음을 애도하며 이야기를 시작합니다.</p>
<h3 id="3">[보위에 대해]</h3>
<p>90년대의 언젠가 즈음에 연락이 끊겼었습니다. 그가 뉴욕에 살고 있는 것을 알고 있었으니 거리나 레스토랑에서 언젠가 만나겠지 싶어, 큰 노력을 하진 않았었습니다. 그리곤 영영 떠나버렸지. 그제서야 큰 후회를 했지만. 그가 죽었다는 것을 믿을 수가 없었습니다. 그가 죽기 이틀 전에 내가 사랑하는 그의 마지막 앨범을 들었는데 생동감 넘치게 들렸습니다. 에너지가 가득했달까.</p>
<h3 id="4">마치 마지막까지 에너지를 쥐어짜낸 것처럼요.</h3>
<p>네, 그런데 그게 그의 마지막일꺼라곤 생각못했죠. 에너지가 넘치고 미래에 대한 희망으로 가득찬 앨범이었으니까요. 유언으로 들리진 않았습니다.</p>
<h3 id="5">이 일에 얽혀있나요? 비슷한 일을 겪어서 그런지 신경쓰고 있는 것 같습니다.</h3>
<p>거의 같은 시기에 저도 검사를 받았기에, 물론이죠. 그가 겪었던 상황을 몸소 느꼈습니다. 저는 운이 좋았지요. 저는 회복했고, 그는 그렇지 않았습니다. 운이 달랐을 뿐입니다.</p>
<h3 id="6">추앙(reverence)에 대해서 어떻게 느끼십니까? 데이빗 보위(David Bowie)나 루 리드(Lou Reed) 같은 사람은 아마 이런 에너지의 무게감을 가졌을 것 같은데요. 스스로 무언가를 의미하게 되는 것을요. 이러한 것을 느끼십니까?</h3>
<p>음, 전통적인 아시아 문화에 영향을 받은 저로써는, 그런 사람이 아닙니다. 저는 도리어 불교적인 것에 흥미를 가지고 있습니다. 무(無)에 대해 오랫동안 생각해왔습니다. 무는 불교 철학의 핵심이죠. 자아(Ego)는 아무 것도 아니고, 보이는 것도 마찬가지 입니다.</p>
<p>저는 전 세계의 토착 문화에 관심이 많습니다. 호주 원주민(Aboriginals), 아메리칸 원주민(Native Americans), 일본의 아이누(Ainu) 사람들이요. 저에겐 그들의 삶의 방식이 익숙하고, 큰 자아를 가진 서양인과는 거리가 멉니다.</p>
<h3 id="7">전 세계의 도시를 순회하며 작업을 할 때, 당신이 누구인지 당신의 음악과 작품과 창의성으로 보여주는데 그 안에 어떤 메세지를 담고 있나요?</h3>
<p>저는 음악으로 정치적이나 사회적인 메세지를 주려하지 않기에, 각 청취자나 독자만의 내용이 될 것입니다.</p>
<blockquote><p>"영화에 담긴 제 젊은 시절 모습을 보았는데, 한 대 패주고 싶었습니다. 자의식 과잉에 욕망과 욕심으로 가득 차 있더군요."</p>
</blockquote>
<h3 id="8">정말요? 저는 작품에 정치적인 메세지를 담고 있다고 생각했습니다.</h3>
<p>글쎄요, 글이라면 그렇겠지만, 음악에는 아닙니다. 기본적으로 저도 사람으로 존재하지만, 제가 음악을 통해 말하는 것은 분리되어 있습니다. 음악은 음악 그 자체로 존재합니다. 제 사회적이나 정치적인 메세지를 전하는 도구가 아닙니다. 저는 그렇게 믿습니다.</p>
<h3 id="9">다큐멘터리를 보셨나요?</h3>
<p>예, 그런데, 그건 제 다큐멘터리가 아닙니다.</p>
<h3 id="10">언제 처음 보셨나요?</h3>
<p>일년 쯤 전에요.</p>
<h3 id="11">젊은 시절 본인의 모습을 처음 보셨을 때 어떠셨나요?</h3>
<p>영화에 담긴 제 젊은 시절 모습을 보았는데, 한 대 패주고 싶었습니다. 자의식 과잉에 욕망과 욕심으로 가득 차 있더군요.</p>
<h3 id="12">참 흥미로운 삶을 살아오신 것 같습니다. 갑자기 사운드트랙 작업에 빠져든 것도 그렇고요. 당신의 삶과 음악에 우울함(melancholia)이 없다고 말하긴 어려울 것 같은데요, 아닌가요?</h3>
<p>그렇습니다. 제 음악엔 항상 존재합니다.</p>
<h3 id="13">당신 자신은 어떤가요?</h3>
<p>저도 그런 것 같습니다.</p>
<h3 id="14">우울함은 어디에서 오나요?</h3>
<p>음, 제 인생에 대해 걱정하다보면 슬픔이 떠오릅니다. 90년대 초반에, 환경 문제로 인해 이 세상에 재난이 찾아올 것을 알게 되었습니다. 그 즈음에 이 문제에 대해 얘기하기로 마음먹었고, 많은 팬들에겐 제가 미친 것처럼 보였을 겁니다.</p>
<p>저는 바흐를 정말 좋아하는데, 그가 음악을 만들던 세상은 슬픔과 비극으로 가득했습니다. 사람들이 수명이 50년 남짓 되었던 시절이죠. 사람들은 신에게 구원해달라고 빌었지만 그런 일은 결코 일어나지 않았습니다. 이런 상황이 바흐에게 그런 슬픈 음악을 만들게 했을 것이고, 저에게도 마찬가지입니다.</p>
<h3 id="15">다큐멘터리에 우연히 나온 프로젝트중 하나가 핵폭탄의 파괴적인 사용을 다룬 <a href="https://www.youtube.com/watch?v=MNn6r98O78c">Opera LIFE</a> 였었습니다.</h3>
<h3 id="16">최근에 맨하탄 프로젝트에 참여했던 과학자들중 마지막 생존자인 <a href="https://www.52-insights.com/freeman-dyson-i-kept-quiet-for-30-years-so-maybe-its-time-to-speak-interview-science/">Freeman Dyson</a>와 인터뷰를 했었는데요, 그는 오펜하이머와 보어가 남긴 어려운 선택에 대해 얘기했습니다. 오펜하이머의 명언 – “나는 세상의 파괴자다.”</h3>
<p>그 프로젝트에 참여했던 사람들의 상황에 대해 이해합니다. 그들은 핵폭탄을 만듦으로써 나찌를 막으려고 했었죠. 나찌가 사라지고 나서 그들은 개발을 멈추려고 했지만, 진지하게 받아들여지지가 않았습니다.</p>
<p>그래서 히로시마와 나가사키에 진짜 핵폭탄을 떨어트리는 대신, 후지산에 폭탄을 떨어트려 산의 모습을 바꾸자는 계획을 군에 제출했었습니다. 후지산은 영적인 산으로 숭배되던 산이었기 때문에, 그 모양을 파괴하면 일본인의 정체성을 흔들 수 있다고 생각했었습니다. 시민을 죽이는 대신 이렇게 하는 것도 과학자들의 의견 중 하나였습니다.</p>
<p>오펜하이머는 핵폭탄의 사용을 목격한 그 순간에 후회했습니다.</p>
<h3 id="17">당신이 원자로가 파괴된 후쿠시마를 방문하는 것과 동시에 방사선 치료를 받고 있었다는 것이 이 영화의 대조적인 부분인데요, 핵은 당신을 도울 수도 있고 파괴할 수도 있습니다. 이 이상한 점에 대해 어떻게 생각하시나요?</h3>
<p>물론, 그 점을 생각했었고, 그렇게 치료받지 않을 수도 있었습니다. 서양의 의학으로 치료받지 않을까도 생각했습니다. 다른 많은 치료 방법에 대해 고민했었지만, 결국엔 좀 더 오래 살고 싶었달까요, 저에겐 자연스러운 결정이었습니다.</p>
<h3 id="18">약간 유머러스하게 들리는데요.</h3>
<p>아이러니하지만, 그렇습니다.</p>
<blockquote><p>"음악의 세계에서는 나이란 아무 것도 아닙니다."</p>
</blockquote>
<h3 id="19">자연을 대하는 것에서도 특별하다고 생각합니다. 후쿠시마를 방문했을 때에, “쓰나미는 원래 상태로 돌아가려는 점에서 마치 복원하려는 성질이 있는 것처럼 행동한다.”고 말했는데요.</h3>
<h3 id="20">우리는 우리 스스로가 중요하다고 생각하겠지만, 실제로는 자연이 항상 스스로를 보호하려는 것처럼 보입니다. 어떻게 생각하시나요?</h3>
<p>글쎄요, 우리가 얘기했던 슬픔과 관련이 있겠네요. 솔직히, 저는 우리 호모 사피엔스가 사라져야 한다고 생각합니다. 우리는 핵폭탄이 아닌 우리의 활동 그 자체로 세상을 파괴하고 있어요. 이 행성과 다른 종에게 있어 우리는 암과 같죠.</p>
<h3 id="21">허나, 이 시점에 우리가 패러다임 전환을 겪고 있는 것은 분명합니다. 뭔가가 일어나고 있습니다.</h3>
<p>너무 늦지 않았기를 바랍니다. 아직 작은 희망이 여기 저기 있긴 하지만, 자본의 힘이란 모든 것을 빠르게 파괴합니다. 지구는 45억년 동안 지속되었고, 그 기간 동안 무언가 나타나고 공룡처럼 사라지기도 했습니다. 인류가 이 곳에 존재하느냐 안하느냐의 문제가 아닙니다. 우리가 생태계의 대부분을 죽여나가는 것이 슬플 따름입니다.</p>
<h3 id="22">음악에 대해서도 좀 얘기해볼까요. 당신의 삶에 사운드 트랙이 있다면 그것은 무엇일까요?</h3>
<p>제 인생의 영화 같은거요?</p>
<h3 id="23">이를테면 영화로 만든다면요. 훌륭한 영화를 위해 음악을 만들어 왔지만, 당신이 좋아하는 사운드 트랙을 꼽는다면요, 당신의 인생에 비유할만한 것이 있을까요?</h3>
<p>누군가의 삶 전체를 음악 하나에 비유한다는건 어쩐지 공평하지 않은 것 같습니다. 사람들의 인생은 그저 음악에 빗대기엔 훨씬 더 복잡하지 않습니까.</p>
<h3 id="24">사람들은 종종 “내 장례식장에서 이 곡을 틀어줘” 같은 얘기를 합니다. 당신이 사랑했던 곳으로 돌아가 어떻게든 당신을 떠올릴 수 있을 만한 곡이 있나요?</h3>
<p>가장 먼저 떠오르는 건 역시 바흐의 음악입니다. 마태수난곡이요. 어쩌면 저같이 이상한 사람에게는 지나치게 우울한 곡일지도 모르겠네요. 너무 무거울 것 같습니다.</p>
<h3 id="25">힙합, 일렉트로니카와 테크노의 출현에 있어 당신의 역할이 중요하다고 봅니다. 제가 좋아하는 몇몇 아티스트들은 당신의 70년대, 80년대, 그리고 90년대의 당신 작품을 참고하고 있습니다. Air에서 Africa Bambaataa에 이르기까지, 모두에게 영향을 주고있는 본인의 역할에 대해 어떻게 생각하나요?</h3>
<p>뭐, 음악의 세계에서 나이란 아무 의미가 없으니까요. 그래서 나이와 세대를 초월해 같은 기분을 공유할 수 있겠죠. 정말 행복합니다. 제가 먼저 시작했기에 그들에게 영향을 주고 있을 뿐이고, 무엇보다 같은 언어로 함께할 수 있어 참 행복합니다.</p>
<h3 id="26">현대 음악도 듣나요?</h3>
<p>그럼요, <a href="https://www.52-insights.com/oneohtrix-point-never-chaos-through-pop-music/">Oneohtrix Point Never</a>를 좋아합니다. 서른살이나 차이가 나지만, 같은 음악에 대해서 떠들 수 있습니다. 저에겐 이런 것이 진정한 행복입니다.</p>
<h3 id="27">마지막 질문입니다. 당신과 연관된 인용구를 말씀해주시겠습니까? “저는 세상의 파괴자 입니다.” 말고요.</h3>
<p>[웃으며] 저는 세상의 파괴자가 되고 싶지 않습니다. 제가 좋아하는 인용구는 “적은 것이 낫다(less is more)” 입니다.</p>
]]></description>
    <pubDate>Thu, 16 Aug 2018 09:03:23 +0000</pubDate>
    
    <author>ez.amiryo@gmail.com (Park Hyunwoo)</author>
    
  </item>
  
  <item>
    <title>Python Community Interview With Mariatta Wijaya</title>
    <link>https://muchtrans.com/translations/interview-mariatta-wijaya.ko.html</link>
    <description><![CDATA[<h1 id="1">마리아타 위자야와 함께한 파이썬 커뮤니티 인터뷰</h1>
<p>이번주의 커뮤니티 인터뷰는, <a href="https://translate.google.com/">마리아타 위자야</a>와 함께합니다.</p><p>
마리아타는 Zapier에서 웹 개발자로 일하면서, 파이썬 커뮤니티를 위한 자발적 활동에 많은 시간을 할애하고 있습니다. 또한 파이썬의 코어 개발자로 활동하며 컨퍼런스와 세미나를 위해 공헌하고 있습니다.</p><p>
마리아타의 이야기가 즐거웠다면, <a href="https://mariatta.ca/category/icecreamselfie.html">#icecreamselfie</a>를 통해 더 알아보거나 깃헙(GitHub)에서 동작하는 그의 봇과 얘기해보세요. 마리아타와 연락할 수 있는 링크를 인터뷰 끝에 마련해 놓았습니다.</p>
<h3 id="2"><strong>릭키:</strong> 쉬운 것부터 시작해보겠습니다. 어떻게 프로그래밍을 시작하게 되었고, 언제부터 파이썬을 쓰고 있나요?</h3>
<p><strong>마리아타:</strong> 중학교 시절에 시작했습니다. 학교에서 특활 활동이 있었는데, 그 중에 하나가 “컴퓨터” 수업이었습니다. 처음에 MS-DOS와 윈도우에 대한 소개에 이어 워드스타와 로터스 스프레드시트를 어떻게 쓰는지 배웠습니다. (제가 좀 늙었습니다.)</p><p>
그 후에 QBASIC으로 프로그래밍을 하게 되었습니다. 그리고 “월드 와이드 웹”을 소개 받고는 HTML을 배우고 어떻게 제 홈페이지를 만드는지 알게 되었습니다. 고등학교를 마친 뒤에 캐나다로 가서 컴퓨터 과학을 전공했구요.</p><p>
파이썬을 사용하기 전에는 .NET 프레임워크와 C#으로 윈도우와 임베딩 애플리케이션들을 만들었습니다. 2008년에 윈도우 프로젝트를 진행하는 스타트업 회사에 있었는데, 프로젝트가 끝나고 나서 다른 팀으로 옮겨야 했습니다.</p><p>
옮긴 팀에서는 웹 기반의 앱을 파이썬, <a href="https://realpython.com/tutorials/django/">장고</a>, 그리고 <a href="https://realpython.com/python-web-applications/#google-app-engine">구글 앱 엔진</a>으로 만들고 있었습니다. 그때 다른 회사를 알아보고 싶지 않아서, 그 팀에 머물러 파이썬을 배우며 웹 개발자로의 새로운 경력을 시작했습니다.</p>
<h3 id="3"><strong>릭키:</strong> 대부분은 당신을 파이썬 코어 개발자로 알고 있을겁니다. 올해 파이콘에서 <a href="https://www.youtube.com/watch?v=hhj7eb6TrtI">What is a Python Core Developer?</a>라는 발표를 하기도 했고요. 발표를 듣지 못한 분들을 위해, 내용을 간단하게 얘기해주실 수 있을까요? 또, 코어 개발자로 당신의 역할에 대해서도요.</h3>
<p><strong>마리아타:</strong> 줄여서 얘기하자면, 파이썬 코어 개발자는 CPython에 코드를 작성하는 것 이상으로 많은 책임감을 필요로 한다는 것입니다. 사실 요즘에는 코어 개발자에게 코드를 작성하는 것을 별로 기대하지 않습니다. 코어 개발자는 직접 Pull request를 작성하는 것보다 코드 리뷰, 멘토링, 피드백을 주고 의사 결정을 하는 일이 더 많습니다.</p><p>
제가 강조하고 싶은 것은, 우리 모두 자원 봉사로 하고 있다는 것입니다. 저는 파이썬 코어 개발자로 <a href="https://www.python.org/psf-landing/">The PSF</a>를 포함한 그 어떤 회사에도 고용되어 있지 않습니다. 아직 많은 분들이 이 점을 모르고 있습니다. 고객 지원 부서에 연락하듯 버그 트래커에 글을 남기고, 즉각적인 응답을 기대하고, 답을 하지 않으면서, 여러 문제로 우리를 비난하는 분들이 종종 있습니다. 우리는 자원봉사로 제한된 여가 시간에 이 일을 할 뿐인데, 몇 명 안되는 우리에 비해 사용자와 기여자는 수 백 수 천 명으로 너무 많습니다.</p><p>
코어 개발자로서 저는 일의 진행을 돕는데 집중하고 있습니다. 특히 다른 코어 개발자와 기여자들이 더 쉽게 기여하고 협업할 수 있도록 하고 있습니다. 이를 위해서 <a href="https://pypi.org/project/cherry-picker/">cherry_picker</a>, <a href="https://github.com/python/miss-islington">miss-islington</a> 같은 도구와, 최근에 <a href="https://check-python-cla.herokuapp.com/">check_python_cla</a> 웹사이트도 만들었습니다.</p><p>
그리고 첫 기여자들과 문서화와 관련된 이슈를 보고 있습니다. 저는 개발자 가이드 문서가 최신을 유지하도록 힘을 쏟는 것을 좋아하는데, 이는 기여자들이 작업하며 문제가 생겼을 때 가장 먼저 찾아볼 곳이기 때문입니다.</p><p>
주간 파이썬 상담 시간(Python office hours)을 Zulipchat을 통해 진행하고 있습니다. <strong>목요일 오후 7시(PST)</strong>에 하고 있습니다. 상담 시간 동안 DM을 보내셔도 됩니다. 가능하면 실시간으로 답하고 도와드리려고 합니다. 다른 시간에는 Zulip을 하루에 한 번 정도 방문하는 편입니다.</p>
<h3 id="4"><strong>릭키:</strong> 파이 레이디스 밴쿠버 밋업과 파이 캐스케이드(PyCascades) 컨퍼런스의 운영자로도 활동하느라 몸이 여러 개여도 모자를 것 같습니다. 어떻게 이런 활동과 연관이 되었는지, 또 이런 모임에 참석한다면 어떤 걸 기대해도 좋을지 조금만 알려주실 수 있을까요?</h3>
<p><strong>마리아타:</strong> <a href="https://2019.pycascades.com/">파이 캐스케이드(PyCascades)</a>가 어떻게 만들졌는지는 저조차도 확실치 않습니다. 제가 아는 것은 Seb이 저에게 이메일을 보냈고, 그래서 다른 사람들(Alan, Eric, Don, 그리고 Bryan)에게 저를 소개한 것 뿐입니다. 그 이메일 타래에 “태평양 북서부에서 파이썬 컨퍼런스를 해볼까요.” 라고 적힌게 전부입니다.</p><p>
저는 곧바로 회신을 했습니다. 이 일에 대해 얼마나 책임져야 하는지, 또 얼마나 많은 노력을 기울여야 하는지 생각하지 않았었습니다. 그저 “왜 안돼?” 라고 했을 뿐이죠. 몇 주만에 밴쿠버에서 장소를 물색하기 시작했고, 나머지도 술술 굴러가기 시작했습니다.</p><p>
파이 캐스케이드도 컨퍼런스의 한 종류입니다. 처음으로 발표하는 사람들과 태평양 북서부 지역의 커뮤니티의 발표자들을 중점적으로 다룹니다. 파이 캐스케이드 2019년의 발표자 모집(CFP)은 8월 20일부터 10월 말까지입니다. 여러분도 꼭 등록해주세요! 올해는 프로그램 선정 위원회에 참여하는대신 발표자를 지원하는 일을 맡았는데, 처음 발표하는 사람들과 잘 드러나지 않은 그룹에서 온 사람들에게 초점을 맞추려고 합니다.</p><p>
파이 레이디스 <a href="http://www.pyladies.com/locations/vancouver/">밴쿠버</a>를 도운지는 2년 밖에 되지 않았습니다. 처음에는 겨우 두 명이 – 그나마 있던 한 명도 그만두고 – 준비위원회를 모집했습니다. 당시 많은 모임에 참가하지는 않았지만, 파이콘에 참석하기 위한 재정지원을 받는데 파이 레이디스로부터 충분한 도움을 받았습니다. 도움을 받은 것을 커뮤니티에 갚기 위한 좋은 기회로 생각되어, 밴쿠버 파이 레이디스 커뮤니티에 지속적이며 적극적으로 참여하게 되었습니다. 다음 모임을 그저 앉아서 기다리는 대신에요.</p><p>
저희 커뮤니티는 점점 커져가고 있습니다. 수 년간 있었던 저희의 이벤트들을 돌아보았는데, 정말 좋은 발표와 워크샵이 많았습니다. 저희 행사에도 파이썬 코어 개발자와 해외의 파이콘 발표자들도 참석하고 있고요. 자랑스럽게 생각합니다.</p>
<h3 id="5"><strong>릭키:</strong> 당신의 깃헙을 좀 살펴봤는데요, 봇(bot)과 제법 친하게 지내시는 것 같더군요. 깃헙에 있는 파이썬 코어 개발에도 두 개를 관리하고, 당신 계정에는 더 많고요. 이런 것들에 왜 매력을 느끼는지 여쭤봐도 될까요?</h3>
<p><strong>마리아타:</strong> 제가 처음으로 깃헙 봇을 소개하게 된건 2년 전에 coala에 기여하면서부터 입니다. 그 프로젝트는 봇을 관리자들을 돕는 개인 비서처럼 쓰고 있습니다. 봇은 항상 작동하고 있고, 댓글과 반응을 보입니다. 그때까진 봇이 이런 일들을 모두 할 수 있는지 몰랐었기 때문에 꽤 감동적이었고 어떻게 작동하는지 이해하는데 빠져들었습니다. 봇이 정말 복잡한 시스템이라고 생각했었거든요.</p><p>
파이썬의 깃헙 봇을 만들고 관리하기 시작하면서, 봇의 구조에 대해 더 잘 이해하게 되었고, 깃헙 봇이 어떻게 동작하는지에 대한 제 호기심도 충족할 수 있었습니다.</p><p>
그때부터 다르게 생각해보게 되었습니다. 이제 어떻게 동작하는지 알고, 어떤 깃헙 API를 사용할 수 있는지 알고나니, 스스로에게 계속 되물었습니다. “뭘 자동화 할 수 있을까? 봇에게 뭘 더 위임할 수 있지? 자동화의 정점에 이른건 아니겠지?” 자동화를 할 수 있는 훨씬 더 많은 일들이 있었고, 제가 필요한건 파이썬이면 충분했습니다. 이젠 어떤 일들을 봇으로 자동화 할 수 있는지 알게되다보니, 따분한 일을 해야할 때 아무래도 성질이 나빠지게 됩니다.</p>
<h3 id="6"><strong>릭키:</strong> 당신과 인터뷰 하면서 아무래도 아이스크림 셀카를 얘기하지 않을 수 없는데요. 이젠 당신의 상징과도 같아졌습니다. 아직 잘 모르는 독자가 있을 수도 있으니, 아이스크림 셀카 – <a href="https://mariatta.ca/category/icecreamselfie.html">#icecreamselfie</a>에 대해 설명을 부탁드립니다.</h3>
<p><strong>마리아타:</strong> 첫번째 <a href="https://mariatta.ca/category/icecreamselfie.html">#icecreamselfie</a>는 필라델피아에서 2016년 7월에 열린 장고콘(DjangoCon)에서 였습니다. 생에 처음으로 컨퍼런스에서 발표를 했었고 기분이 너무 좋아 축하해야겠다는 생각이 들었습니다. 그리고 엄청 더운 날이기도 했죠. 그래서 호텔 근처의 아이스크림 가게로 찾아갔습니다. 어쩐지, 아이스크림을 들고 셀카를 찍고 싶어졌습니다. 평소에는 잘 하지 않는데 말이죠. 보통은 셀카를 찍지 않고 음식을 찍는 편입니다.</p><p>
다음 발표는 푸에르토리코의 파이 캐리비안이었습니다. 아이스크림은 생각조차 하지 않고, 저와 제 룸메이트, 다른 발표자였던 Kim Crayton과 해변을 즐기고 있었습니다. 근데 갑자기 아이스크림 카트가 짠–하고 나타난거죠.</p><p>
그 다음에는 장고콘 유럽과 파이콘 이탈리아를 위해 이탈리아를 방문했습니다. 물론 젤라또를 먹었습니다. 그러지 않고는 이탈리아를 여행했다고 할 수 없으니까요. 그때만 해도 #icecreamselfie가 전통이 될 줄 몰랐습니다. 셀카는 이제 우연한 일 이상이 되었습니다.</p><p>
꽤나 감정적인 발표였던 파이콘 US의 발표를 마친 후에 제 머릿속에는 아이스크림 밖에 없었습니다. 그래서 제 친구 제프가 포틀랜드에서 그가 알고 있는 곳으로 저를 데려갔습니다. 아이스크림을 먹고 나니 기분이 좋아졌습니다! 그때부터는 #icecreamselfie 가 저의 공식적인 전통이 되었고, 발표가 정해지기만 하면 최고의 아이스크림을 찾는데 굉장히 공을 들이고 있습니다.</p>
<h3 id="7"><strong>릭키:</strong> 자, 이제 마지막 질문입니다. 파이썬 외에 다른 취미나 흥미가 있다면? 공유하거나 연결해주고 싶은 사람이 있을까요?</h3>
<p><strong>마리아타:</strong> 저는 걷고, 여행하고 캠핑하는 것을 좋아합니다. 제 음식을 찍어 인스타그램에 올리는 기이한 취미를 가지고 있고요. 다른 취미로는 마작을 합니다. 보통의 마작 게임이 아니라 홍콩 스타일의 마작입니다. 저 말고 이 게임을 하는 사람을 찾기가 어렵네요.</p><p>
저를 돕는데 관심이 있는 분은, <a href="https://www.happinesspackets.io/">happiness packet</a>를 보내주시거나, <a href="https://www.patreon.com/Mariatta">Patreon</a>을 통해 후원해주셔도 되고, <a href="https://saythanks.io/to/Mariatta">just say thanks</a>만 해주셔도 좋습니다.</p>
<hr>
<p>인터뷰를 해준 마리아타에게 감사합니다. 마리아타에게 더 궁금한 것이 있다면 마리아타의 <a href="https://twitter.com/mariatta">트위터</a>와 <a href="https://mariatta.ca/">홈페이지</a>를 찾아보세요.</p>
]]></description>
    <pubDate>Sat, 01 Sep 2018 13:11:11 +0000</pubDate>
    
    <author>ez.amiryo@gmail.com (Hyunwoo Park)</author>
    
    <author>joeunpark@gmail.com (Joeun Park)</author>
    
    <author>Bloodevil4@gmail.com (yeaji shin)</author>
    
  </item>
  
  <item>
    <title>My Path to Becoming a Python Core Developer</title>
    <link>https://muchtrans.com/translations/my-path-to-becoming-a-python-core-developer.ko.html</link>
    <description><![CDATA[<h2 id="1">파이썬 코어 개발자가 되기까지</h2>
<p>저는 파이콘에 2015년에 처음 참가했습니다. 몬트리올에서 열렸는데, 캐나다에도, 성인이 되어 해외로 가보는 것도 처음이었습니다. 남편과 함께 (당시에는 남자친구였지요) 회사를 시작한 지 6개월이 된 시점이었습니다. CuttleSoft를 창업하는 데 전념하기 위해 대학원을 그만두고 4개월쯤 지났을 때였습니다.</p>
<p>모든 일이 지난 지금은 완전히 다른 시각을 가지게 되었지만, 당시에는 위험을 감수하는 것이 옳은 선택인지에 대한 확신이 없었습니다. 필사적으로 제가 살던 곳을 떠나 무언가 새로운 것을 경험하고 싶었습니다. 어디서 살았는지 기억하기 시작한 때로부터 한곳에 너무 오래 머물렀다는 느낌이었습니다. 계속해서 언어 이론, 형식 검증, 그리고 컴파일러에 대한 공부를 이어갈 수 있는 대학원을 찾고 싶었지만, 빛나는 새 도시의 다른 대학으로 옮겨가기 위해 이듬해까지 기다려야만 했습니다.</p>
<p>흥분과 불안함과 불확실의 파도가 계속해서 몰아쳤지만, 그래도 대부분은 흥분되는 일들이었습니다.</p>
<p>어렸을 적부터 열심히 하면 뭐든지 할 수 있다는 얘기를 들으며 자라기도 했거니와, 새싹 회사임에도 프랭크와 저를 <em>캐나다</em>에서 하는 컨퍼런스에 보낼 능력이 된다는 것은 제가 옳은 길로 가고 있다는 신호였습니다. 열정적으로 했던 일을 두고 왔다는 불안감은 여전히 있었습니다만, 언젠가 다시 대학원에 돌아갈지 말지 누가 알 수 있을까요?</p>
<p>그 해의 파이콘 스피커 중 한 명은 파이썬의 사랑받는 창시자이자 BDFL인 귀도 반 로섬이었습니다. 그는 키노트 중에 이듬해의 파이콘 전까지 최소 2명의 여성 코어 개발자를 선정하는 것을 공개적인 목표로 하며 같이 행동하기를 요청했습니다. 당시에는 한 명도 없었습니다. 프랭크는 “당신이 꼭 해야 해! 완전히 딱이라고” 라며 나를 부추겼습니다. 저는 그때까지 귀도에 대해서는 잘 몰랐었지만, 그와 얘기하는 것을 상상만 해도 겁에 질릴 정도였습니다.</p>
<p>어느 날 밤, 우리는 귀도가 참석하는 한 이벤트에 같이 참여하게 되었습니다. 프랭크와 다른 컨퍼런스 참가자들이 그에게 가서 얘기해보라며 응원해 줬습니다. “지금 가서 말하지 않는다면, 과연 다른 기회가 있을까?”라고 생각했죠.</p>
<p>귀도는 말수가 많은 편은 아니었습니다. 그처럼 널리 알려진 사람에게는 컨퍼런스가 부담스러울 수도 있지만, 당시에는 잘 몰랐었습니다. 저는 그에게 잠깐 얘기할 수 있는지 물었고, 그는 “물론이죠!”라고 답했는데, 제가 존경하는 방식이었습니다. (그때까지 열정적이고 격려를 잘하는 사람인 줄은 몰랐습니다) 저는 제 소개와 함께 파이썬에 대한 제 사랑과 그간 공부했던 파서, 컴파일러, 언어 이론에 대해 설명을 했습니다. 그의 행동 촉구 메시지를 들었고, 파이썬에 정말로 기여하고 싶다고 말했습니다.</p>
<p>주절주절 말하는 동안에 컨퍼런스에서 새롭게 만난 친구가 걸아가다 귀도와 제가 얘기하고 있는 모습을 플래시를 번쩍 터트려 찍었습니다. 조명이 거의 없는 어두운 곳이었는데, 나중에야 알게 된 것이지만 저는 완전히 긴장해서 얼굴이 빨갛게 변해버렸습니다(저만의 진정한 기술이죠). 이런 부류의 사람을 거의 만나본 적이 없던 저로서는 이미 제 안전지대를 완전히 벗어났다는 느낌이 들었습니다. 우리는 일단 그 일을 무시하고, 그는 나중에 더 얘기할 수 있으니 메일을 보내 달라고 말했습니다.</p>
<p>하지만 보내지 않았습니다. 두렵고 부끄러웠습니다.</p>
<p>파이콘 2016에 다시 참석했지만, 여전히 여성 코어 개발자는 없었습니다. 귀도는 코어 개발에 관심 있는 여성이 있다면 개인적으로 멘토가 되어주겠다는 새로운 발표를 했습니다. 다시 한번, 이렇게 생각했습니다. “내가 어떻게 <em>안</em>할 수 있어?”. 그래서 그에게 부끄러웠던 플래시 사진을 기억하는지 농담으로 물어보며 메일을 보냈습니다. (돌이켜보면, 그는 아마도 이튿날 그 일을 완전히 잊어버렸겠죠)</p>
<p>거기서부터 이야기가 시작되었습니다. 네, 교과서에서 읽은 역사와 같은 일들이 이어졌습니다. 길고, 늘어지고 지루한 그런 일들요. 새로운 기여자에게 추천되는 일은 주로 문서를 작성하고 버그를 고치는 것들입니다. CPython의 알려진 문제점들은 단순하지 않고, 코어 개발팀 내에서 어떻게 해볼 수 없는 일들로 이루어져 있어 어려웠습니다. 쉬운 일들은 엄청나게 빨리 고쳐지는 데 반해서 말이죠. 하지만 CPython의 문서화나 버그 수정만을 위해 온 것이 아니었기 때문에 산더미 같은 소스 코드를 읽기 시작했고, 수도 없이 많은 print 구문을 찍어가며 CPython의 코어 구현을 알아가기로 했습니다.</p>
<p>귀도는 제가 이 일을 헤쳐나갈 수 있도록 도움(이라고 쓰고 웃음이라고 읽습니다)을 주었습니다. 15년 이상 아무도 건드리지 않아 거미줄이 가득한 코드의 구석에서 제가 살펴볼 코드 조각을 골라냈습니다. 이런 식으로 매주 저는 귀도와 만나 제가 찾은 코드에서 흥미롭거나 헷갈리는 부분을 물어보았습니다. 하지만 논문을 읽던 것에서 별로 달라지진 않았죠. (또는, GitHub PR을 세어보세요 (하지만 하지 않길 바랍니다))</p>
<p>저는 파이콘 2017에서 열린 <a href="https://lwn.net/Articles/723251/">Language Summit</a>에 초대받은 덕에, 열정을 되살릴 수 있었습니다. 감사한 마음으로 참석하여 가능한 한 많이 듣고 배우고자 했습니다. 티켓을 사지 않고 영화관에 몰래 들어온 아이 같은 기분이 들었습니다. 누구와도 대화하지 않고 자리에 앉아 관찰하고 들었습니다. 파이콘 2017도 그랬습니다. 그저 왔다가, 갔습니다.</p>
<p>이 과정에서 목표를 상실한 것 같은 느낌이 자주 들었습니다. 실제로 하는 일 없이 이것저것 했다 말았다 했는데, 정말 끔찍한 기분이었죠. 물론 편안함을 느낄 때도 있었고, 이런 기회를 얻기가 쉽지 않음을 인지하며, CPython의 내부 동작에 대해 배우는 것은 <em>정말 좋았</em>지만, 어쩐지 불안한 마음이 들고, 다음에 귀도를 만날 땐 어쩐지 그가 “흠, 요점이 뭔지 모르겠네요. 당신이 뭘 하고 있는지조차 잘 모르겠으니, 그걸 찾아내길 바라요.” – 실제로 그렇게 말한 적은 결코 없지만 — 라고 말할 것만 같았습니다. 그렇지만, 내 머릿속의 부정적인 목소리가 나를 지배하는 듯 했고, 귀도의 시간을 낭비하게 하는 게 아닐까 걱정도 되었습니다. 정말 저 자신에게 실망하고 말았죠.</p>
<p>파이콘 2018과 함께 다시 한번 <a href="https://lwn.net/Articles/754152/">Language Summit</a>이 찾아왔습니다. 이번에는 다른 코어 개발자들과 확실히 만나 실제로 얘기를 나눴습니다. 이전보다 더 열심히 <a href="https://mail.python.org/mailman/listinfo/python-dev">Python-Dev</a> 와 <a href="https://mail.python.org/mailman/listinfo/python-ideas">Python-Ideas</a> 메일링 리스트를 따라잡은 덕에, 상대적으로 이야기할 거리가 생긴 기분이 들었습니다. 그제야 대부분의 코어 개발자들은 정말 친절하고 환영해준다는 것을 알았습니다. (문화는 위에서 아래로 전파되며, 귀도는 이런 커뮤니티를 이끄는 데 중요한 역할을 해냈습니다) 예전보다 더 환영받는 기분이 들었습니다. 사람들은 제 이야기에 귀를 기울여주었고, 저는 그들의 이야기를 들었습니다. 요즘 가장 화젯거리인 문제들의 기술적인 세부 사항에 대해서 떠들기 시작했습니다. 정말 최고였습니다. 에릭 스노우는 저를 그의 작업인 <a href="https://www.python.org/dev/peps/pep-0554/">PEP 554 (Multiple Interpreters in the Stdlib)</a>에 참여할 수 있도록 초대해주기도 했습니다. 아이디어를 주고받다가도 필요할 때는 세부 사항을 구현하기도 하는 대단한 협업 멘토링을 경험할 수 있었습니다. (귀도와 했던 것과는 꽤 달랐는데, 이건 나중에 블로그에 따로 적어보겠습니다)</p>
<p>그리고 결국, 엄청난 일이 일어나고 말았습니다. <a href="https://www.python.org/dev/peps/pep-0572/">PEP 572 (Assignment Expressions)</a>이 파이콘 2018 직후에 승인되었죠. 귀도가 누구에게 구현하라고 요청했는지 한 번 맞춰보세요. 제가 목적 없이 연구해오던 것들이 돌연 실질적인 의미를 가지게 되었습니다.</p>
<p>그 작업에서 저는 기록적인 시간 내에 개념 증명을 위한 구현을 했습니다. (가장 쉬운 일이 처음에 왔는데, 제가 예전부터 준비해오던 것이기에 그러했습니다) 모든 요구 사항을 만족시킬 때까지 반복해서 구현하였으며, 2018년 9월에 있었던 파이썬 코어 개발자 스프린트에서 세부 사항을 완성하기 위해 귀도와 함께 작업하였습니다. 95% 정도 완료되었을 때, 저는 <a href="https://mail.python.org/pipermail/python-committers/2018-September/006059.html">본격적인 코어 개발자로 승진</a>할 수 있었습니다. 이 일을 시작한 지 3년만의 일입니다. 구현이 완전히 자리 잡기 위해 손봐야 할 여러 작업이 있었지만, 그건 그거고, 이제 온전히 “저 자신”이 돌봐야 하는 언어의 한 부분이 생긴 것입니다.</p>
<p>저는 사람들마다 방법이 다를 수 있음을 알리기 위해 글을 적었습니다. 파이썬 코어 개발자가 되는 것은 영예나 명예롭다기보다는 어렵기만 하고, 인정받지 못 하는 일에 가깝습니다. 하지만  적성에 맞는다면 <em>꽤</em> 흥미로우며 보람찬 일일 수 있습니다. 저에게는 이것이 바로 프로그래밍 언어 디자인과 컴파일러에 대한 제 사랑을 표현하는 완전한 방법이었습니다. 또한 예상할 수 없었던 방법으로 제 능력을 계속해서 배우고 사용할 수 있고, 제가 사랑하는 파이썬 커뮤니티에 보답하는 방법이기도 합니다.</p>
]]></description>
    <pubDate>Mon, 28 Jan 2019 11:35:17 +0000</pubDate>
    
    <author>ez.amiryo@gmail.com (Park Hyunwoo)</author>
    
  </item>
  
  <item>
    <title>Notes on structured concurrency, or: Go statement considered harmful</title>
    <link>https://muchtrans.com/translations/notes-on-structured-concurrency-or-go-statement-considered-harmful.ko.html</link>
    <description><![CDATA[<h1 id="1">구조적 동시성에 대한 소고, 또는 Go 문의 해로움</h1>
<p>모든 동시성 API는 코드를 동시에 실행할 방법을 필요로 하죠. 서로 다른 API 들이 어떻게 생겼는지 한 번 볼까요.</p>
<pre><code>go myfunc();                                // Golang
pthread_create(&amp;thread_id, NULL, &amp;myfunc);  /* C with POSIX threads */
spawn(modulename, myfuncname, [])           % Erlang
threading.Thread(target=myfunc).start()     # Python with threads
asyncio.create_task(myfunc())               # Python with asyncio
</code></pre>
<p>다양한 표기법과 서로 다른 용어가 있겠지만, 문법적으로는 모두 같습니다. 모두 <code>myfunc</code>를 프로그램의 나머지 부분과 동시에 실행하려는 것이며, 즉시 돌아와 부모가 나머지 부분을 실행할 수 있도록 하는 것이죠.</p>
<p>다른 방법으로는 콜백을 사용하는 것도 있겠습니다.</p>
<pre><code>QObject::connect(&amp;emitter, SIGNAL(event()),        // C++ with Qt
                 &amp;receiver, SLOT(myfunc()))
g_signal_connect(emitter, "event", myfunc, NULL)   /* C with GObject */
document.getElementById("myid").onclick = myfunc;  // Javascript
promise.then(myfunc, errorhandler)                 // Javascript with Promises
deferred.addCallback(myfunc)                       # Python with Twisted
future.add_done_callback(myfunc)                   # Python with asyncio
</code></pre>
<p>다시 한번, 표현만 다를 뿐 같은 일을 수행합니다. 지금부터 어떤 이벤트가 발생하면 <code>myfunc</code>를 실행하라는 것입니다. 한 번 설정되고 나면 즉시 되돌아와 부른 쪽에서 다른 일을 할 수 있게 되죠. (콜백이 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">promise</a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race">combinators</a>, 또는 <a href="https://twistedmatrix.com/documents/current/core/howto/servers.html">Twisted-style protocols/transports</a>와 같이 그럴싸해 보이는 형태로도 제공됩니다만, 결국 근간은 같습니다.)</p>
<p>그리고... 그렇죠. 실제로 사용되는 일반적인 그 어떤 동시성 API를 가져다 놓더라도 아마 둘 중 한쪽에 속할 겁니다 (가끔 asyncio와 같이 양쪽에 속하는 경우도 있죠).</p>
<p>하지만 제가 만든 새로운 라이브러리인 <a href="https://trio.readthedocs.io">Trio</a>는 좀 다릅니다. 어느 쪽에도 해당하지 않죠. 대신, <code>myfunc</code>와 <code>anotherfunc</code>를 동시에 실행하고 싶다면, 아래와 같이 하면 됩니다.</p>
<pre><code>async with trio.open_nursery() as nursery:
    nursery.start_soon(myfunc)
    nursery.start_soon(anotherfunc)
</code></pre>
<p>"nursery" 구조를 처음 본 사람이라면 이게 뭔가 싶을 겁니다. 웬 들여쓰기가 있나? <code>nursery</code> 객체는 또 뭐고, 태스크를 실행하기 위해 왜 이런 걸 하나? 싶으실 겁니다. 그리고 나서는 다른 프레임워크에서 익숙하게 썼던 패턴을 사용하지 못해 짜증이 나겠죠. 기본 요소라기엔 기이하고 특이하며 너무 고급(high-level)처럼 느껴질 겁니다. 뭐 예상되는 반응입니다! 하지만 좀 참아보세요.</p>
<p><strong>이 포스트를 통해, 저는 nursery가 이상하거나 특별하지 않으며, 반복문이나 함수 호출과 같이 근본적으로 새로운 흐름 제어 방식임을 알리고자 합니다. 그리고, 위에서 봤던 기존의 방법 – 쓰레드 복제나 콜백 등록 – 들은 nursery로 완전히 대체되어야 한다고 봅니다.</strong></p>
<p>이상하게 들리나요? 비슷한 일이 예전에도 있었습니다: 바로 <code>goto</code>가 흐름 제어의 시작과 끝이던 시절이 있었지만, 이젠 <a href="https://xkcd.com/292/">다 흘러간 얘기</a>가 된 것처럼요. 몇몇 언어들이 아직 <code>goto</code>라 불리는 것을 가지고 있지만 예전에 <code>goto</code>라 불리던 것과 비교하면 다르고 기능이 제한되어 있습니다. 게다가 대부분의 언어에는 아예 없고요. 무슨 일이 있었냐고요? 옛날 옛적 일이라 아는 사람이 별로 없는 이야기지만 놀랄 정도로 유사한 이야기임을 알게 되실 겁니다. 그럼 이제 <code>goto</code>가 어떤 것이었는지 알아보는 걸로 시작해서 그 이야기가 왜 동시성 API에 대한 얘기로 이어지는지 알아봅시다.</p>
<h2 id="2">도대체 <code>goto</code> 문이 뭐길래?</h2>
<p>자, 역사를 살펴봅시다. 초기의 컴퓨터는 <a href="https://en.wikipedia.org/wiki/Assembly_language">어셈블리 언어</a>나, 그보다 더 원시적인 방법들로 동작했습니다. 아주 거지 같았죠. 1950년대가 돼서야 IBM의 <a href="https://en.wikipedia.org/wiki/John_Backus">존 배커스</a> 나 Remington Rand의 <a href="https://en.wikipedia.org/wiki/Grace_Hopper">그레이스 호퍼</a> 같은 사람들이 <a href="https://en.wikipedia.org/wiki/Fortran">FORTRAN</a>과 <a href="https://en.wikipedia.org/wiki/FLOW-MATIC">FLOW-MATIC</a> (그 후속작인 <a href="https://en.wikipedia.org/wiki/COBOL">COBOL</a>이 유명하죠) 같은 언어를 개발하기 시작했습니다.</p>
<p>FLOW-MATIC은 당시로썬 상당히 비범했습니다. 컴퓨터보다는 인간 친화적으로 만들어진 첫 번째 프로그래밍 언어로 파이썬의 할머니의 할아버지의 할머니 정도로 여겨도 됩니다. FLOW-MATIC 코드 맛 좀 볼까요.</p>
<object data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/flow-matic-1.svg" style="width: 440px;" type="image/svg+xml"> </object><p>현대적인 언어와는 다르게 <code>if</code>도 없고 반복문이나 함수 호출도 없군요. 알고 보면 블록 구분자와 들여쓰기조차 없습니다. 연속된 구문의 목록일 뿐입니다. 이 프로그램이 단지 짧거나 그럴싸한 제어 문법이 없어서가 아니라, 이 시절엔 아예 블록이라는 게 발명되지도 않았기 때문이죠!</p>
<object data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/sequential-and-go-to-schematic.svg" style="width: 400px;" type="image/svg+xml"> Sequential flow represented as a vertical arrow pointing down, and goto flow represented as an arrow that starts pointing down and then leaps off to the side.</object><p>대신 FLOW-MATIC에는 두 가지 제어 방식이 있습니다. 보통은 예상한 대로 위에서 아래로 한 구문씩 순차적으로 실행됩니다. 하지만 <code>JUMP TO</code>같은 특별한 구문을 만나면 다른 곳으로 옮겨탑니다. 예를 들어, 구문(13)은 구문(2)로 점프합니다.</p>
<object data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/flow-matic-2.svg" style="width: 440px;" type="image/svg+xml"> </object><p>제가 만든 동시성 기초 요소(역주: nursery)와 마찬가지로, 이 "단방향 점프"를 무엇으로 불러야 하는지 논란이 있었습니다. 여기서는 <code>JUMP TO</code>라고 했지만, 그 이름은 <code>goto</code>로 굳어지게 됩니다. ("go to" 같은 거죠) 여기서는 이렇게 부르겠습니다.</p>
<p>자, 이제 이 작은 프로그램의 완전한 <code>goto</code> 점프 구성을 봅시다.</p>
<object data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/flow-matic-4.svg" style="width: 440px;" type="image/svg+xml"> </object><p>여러분에게만 이게 혼돈의 카오스로 보이는 건 아닙니다. 이런 식의 점프 기반 프로그래밍은 FLOW-MATIC이 어셈블리 언어로부터 직접적인 영향을 받은 것입니다. 강력하며, 컴퓨터 하드웨어가 동작하는 방식에 딱 맞지만, 직접적으로 사용하기에는 혼란스럽죠. 이 화살표 더미로부터 "스파게티 코드"라는 명칭도 나왔습니다. 더 나은 게 필요합니다.</p>
<p>흠... 이 모든 문제를 일으키는 <code>goto</code>란 무엇일까요? 왜 어떤 제어문은 괜찮고 어떤 건 안될까요? 어떻게 좋은 걸 고르죠? 당시에는 이게 명확하지 않기도 해서, 이해하지 못한다면 문제 해결이 정말 어려울 겁니다.</p>
<h2 id="3"><code>go</code> 문은?</h2>
<p>하지만 잠깐, 모두가 <code>goto</code>가 나쁘다고 외치는 역사의 한순간에 멈춰볼까요? 이 얘기가 동시성과 관련이 있냐고요? 뭐, Golang의 유명한 <code>go</code> 문을 생각해봅시다. 새로운 "goroutine"(경량 쓰레드)을 만들어 보죠.</p>
<pre><code>// Golang
go myfunc();
</code></pre>
<p>이 흐름을 다이어그램으로 그려볼까요? 음, 위에서 봤던 것과 좀 다릅니다. 흐름이 갈라지니까요. 그림으로 그려보면요,</p>
<object class="align-center" data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/go-schematic-unlabeled.svg" style="width: 395px;" type="image/svg+xml"> "Go" flow represented as two arrows: a green arrow pointing down, and a lavender arrow that starts pointing down and then leaps off to the side.</object><p>일부러 <em>양쪽</em> 선의 색상을 다르게 했습니다. 순차적으로 실행될 부모 goroutine(초록선)은 위에서 시작해서 즉시 아래로 진행합니다. 그동안 자식(라벤더색)은 위에서 시작해서 <code>myfunc</code> 본체로 점프합니다. 일반적인 함수 호출과 다르게, 이 점프는 단방향입니다. <code>myfunc</code>의 실행은 완전히 새로운 스택에서 이뤄지고, 런타임은 이 실행이 어디에서 시작되었는지도 모릅니다.</p>
<p>이건 Golang에만 해당하는 것은 아닙니다. 이 흐름은 글의 시작에 열거했던 <em>모든</em> 기초 요소에 적용됩니다.</p>
<ul>
<li>쓰레딩 라이브러리는 일반적으로 나중에 쓰레드를 결합(<code>join</code>) 할 수 있는 객체를 제공합니다. 하지만 언어 차원에서는 알 수 없는 독립적인 작업입니다. 실제 쓰레드 복제 요소는 위와 같은 제어 흐름을 가집니다.</li>
<li>콜백을 등록하는 것도 문법적으로는 다음과 같은 백그라운드 쓰레드를 시작하는 것과 같습니다. (a) 어떤 일이 발생할 때까지 멈춰있다가, (2) 콜백을 호출합니다. (구현은 완전히 다르게 되겠지만요.) 상위 수준의 흐름 제어로 보자면, 콜백 등록도 <code>go</code> 문과 동일합니다.</li>
<li>Future와 promise도 마찬가지입니다. promise를 돌려주는 함수를 호출하는 것은 백그라운드로 일어날 일을 예약한다는 것과 같습니다. 그리고 나중에 결합(join)할 객체를 – 원한다면 – 돌려줍니다. 흐름 제어 측면에서 보면, 쓰레드를 생성하는 방식과 같죠. 그리고 promise에 콜백을 등록하는 것이니 두 번 말할 것도 없습니다.</li>
</ul>
<p>이 같은 패턴이 다양한 형태로 나타납니다. 이 다양한 형태의 핵심은 제어 흐름이 갈라지며, 한쪽은 단방향으로 점프하고 다른 한쪽은 호출했던 쪽으로 돌아간다는 것입니다. 뭘 봐야할 지 알게 되면, 같은 것을 여러 곳에서 찾아볼 수 있을겁니다 – 정말 즐거운 일이죠! <sup class="footnote-ref" id="tfnref-1"><a href="#tfn-1">1</a></sup></p>
<p>그런데, 이러한 흐름 제어를 부르는 공통된 이름이 없습니다. "<code>goto</code> 문"이 다른 <code>goto</code> 같은 구문을 통칭하는 이름이 된 것과 같이, 저도 이런 형태를 모두 "<code>go</code> 문"이라고 부르려고 합니다. 하필 왜 "go" 라고 묻는다면... Golang에 이러한 형태에 대한 명백한 예제가 있달까요. 어쨌든 이제 다들 제가 이걸 가지고 뭘 하려는지 알 것 같은데요. 이 두 다이어그램을 보세요. 비슷하지 않나요?</p>
<object class="align-center" data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/go-schematic-and-go-to-schematic.svg" style="width: 400px;" type="image/svg+xml"> Repeat of earlier diagrams: goto flow represented as an arrow that starts pointing down and then leaps off to the side, and "go" flow represented as two arrows: a green arrow pointing down, and a lavender arrow that starts pointing down and then leaps off to the side.</object><p>맞아요. <strong>go 문은 goto 문과 형태가 같습니다.</strong></p>
<p>동시성 프로그래밍은 작성하고 동작을 추론하기가 어려운 것으로 악명이 높죠. 마치 <code>goto</code>-기반 프로그램이 그러했던 것처럼요. 같은 이유로 그런 것은 아닐까요? 현대 언어들에서는 <code>goto</code> 문제가 상당수 해결되었죠. 우리가 <code>goto</code>를 해결한 것과 마찬가지로 이를 통해 사용하기 쉬운 동시성 API를 만들어낼 수 있을까요? 한 번 알아봅시다.</p>
<h2 id="4"><code>goto</code>에 무슨 일이 있었던 거야?</h2>
<p>당최 <code>goto</code>가 뭐길래 이렇게 많은 문제를 낳았을까요? 1960년대 후반에 <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">에츠허르 데이크스트라</a>는 <a href="https://scholar.google.com/scholar?cluster=15335993203437612903&amp;hl=en&amp;as_sdt=0,5">Go to의 해로움</a>과 <a href="https://www.cs.utexas.edu/~EWD/ewd02xx/EWD249.PDF">구조적 프로그래밍에 대한 소고</a> (PDF)와 같이 이 문제를 명확하게 설명하는, 근래에 매우 유명해진 글을 남겼습니다.</p>
<h3 id="5"><code>goto</code>: 추상화의 파괴자</h3>
<p>이 문서들에서 데이크스트라는 비순차적 소프트웨어를 작성하고 잘 동작하게 만드는 문제에 대해 우려했습니다. 이러한 통찰에 대해 감히 제가 여기서 평가할 수는 없습니다. 예를 들자면, 이런 얘기를 들어보셨을 겁니다.</p>
<p><img src="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/testing.png" alt="Testing can be used to show the presence of bugs, but never to show their absence!"></p>
<p>이건 <em>구조적 프로그래밍에 대한 소고</em>에서 발췌한 것입니다. 하지만 그는 주로 <em>추상화</em> 에 대해 신경을 썼습니다. 그는 머릿속에 다 담을 수 없을 정도로 거대한 프로그램을 만들고 싶어 했습니다. 이를 위해 프로그램의 각 부분을 블랙박스처럼 다룰 필요가 있죠. 파이썬 프로그램을 예로 들어보겠습니다.</p>
<pre><code> print("Hello world!")
</code></pre>
<p>문자열 포매팅, 버퍼 관리, 크로스플랫폼 이슈 등... <code>print</code>가 어떻게 구현되어 있는지 알 필요는 없습니다. 그저 당신이 입력한 문자열이 표시될 것이라는 것만 알면 코드의 다른 부분을 작성하는 데 전념할 수 있습니다.  데이크스트라는 이러한 추상화가 프로그래밍 언어 수준에서 제공되길 원했습니다.</p>
<p>이 지점에서, 블록 문법이 발명되었고, ALGOL과 같은 언어에는 5가지 정도의 서로 다른 흐름 제어 구문이 있게 되었습니다. 여전히 순차적으로 실행되고 <code>goto</code>도 있었지만요.</p>
<p>앞서 나왔던 순차 진행과 goto 진행을 봅시다.</p>
<object data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/sequential-and-go-to-schematic.svg" style="width: 400px;" type="image/svg+xml"> Same picture of sequential flow and goto flow as before.</object><p>그리고 비교문, 반복문, 함수 호출 등이 생겨났죠.</p>
<object class="align-center" data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/control-schematics.svg" style="width: 500px;" type="image/svg+xml"> Diagrams with arrows showing the flow control for if statements, loops, and function calls.</object><p>이 고급 기능을 <code>goto</code>로 만들 수도 있고, 초창기 사람들은 실제로 편리한 줄여 쓰기 정도로 여겼습니다. 하지만 데이크스트라는 이러한 다이어그램을 봤을 떄, <code>goto</code>와 다른 것들 사이에는 차이가 있다고 지적했습니다. <code>goto</code> 말고 나머지는 위에서 시작해서 → [뭔가 하고] 나서 → 아래로 내려가는 식으로 흘러갑니다. 이렇게 생겨 내부에서 뭘 하는지 신경 쓸 필요가 없는 모습을 "블랙박스 룰"이라고 불러보죠. [뭔가 하고] 부분을 무시하고 나면 전체적으로 봤을 때 그저 차례대로 흘러가는 것으로 볼 수 있습니다. 그리고 이런식으로 구성된 그 어떤 코드들에 대해서도 똑같이 여길 수 있으니까 좋죠. 이 코드를 다시 볼까요.</p>
<pre><code> print("Hello world!")
</code></pre>
<p><code>print</code>의 정의나 그것의 전이적 의존성(transitive dependencies)을 찾아보지 않더래도 일이 어떻게 돌아가는지 알 수 있습니다. <code>print</code> 안에 반복문이 있을 수도 있고, 그 반복문 안에 비교문이 있고, 또 그 안에 다른 함수 호출이 있고... 뭐 이것저것 있을 수 있죠. 하지만 뭔 상관이에요. <code>print</code> 내부로 흘러갔다가 그 안에서 뭔가 하고, 결국엔 제가 읽고 있는 코드로 돌아올 게 뻔하니까요.</p>
<p>되게 뻔한 것처럼 보이겠지만, 만약 <code>goto</code>가 있는 언어를, 아니, 모든 것들이 <code>goto</code> 위에서 만들어진 언어를 생각해보세요. 그리고 이 <code>goto</code>는 아무 때나 아무 곳으로나 갈 수 있죠. 이런 상황에서는 제어 구조가 전혀 블랙박스화 되지 않아요! 함수가 있는데, 그 함수 안에 반복문이 있어요. 그 안에 비교문이 있는데, 그 비교문 안에 <code>goto</code>가 있고... 그리고 <code>goto</code>는 어디든 간에 원하는 대로 가버릴 수 있죠. 호출한 적도 없는 완전히 다른 함수로 갑자기 가버릴 수도 있어요. 이걸 어떻게 알죠!</p>
<p>이렇게 추상화가 무너집니다. 다시 말하자면 이건 모든 함수 호출이 잠재적으로 <code>goto</code>의 변형된 형태라고 볼 수 있다는 것이고, 이걸 알려면 모든 시스템의 코드를 머릿속에 넣고 있어야 한다는 뜻입니다. 프로그래밍 언어에 <code>goto</code>가 있는 한, 흐름 제어의 지역적 추론이 불가능하다는 것입니다. 이래서 <code>goto</code>가 스파게티 코드를 만들게 되죠.</p>
<p>데이크스트라가 이 문제를 이해한 덕분에, 해결할 수 있었습니다. 이 혁명적인 제안을 보시죠. 우리는 비교문/반복문/함수 호출을 <code>goto</code>의 줄임말이라고 생각하지 말고, 각각의 기능이 있는 근본적인 기본 요소로 삼아야 합니다. 그러려면 <code>goto</code>를 우리 언어에서 완전히 쫓아내야 합니다.</p>
<p>2018년인 지금은 이 얘기가 굉장히 명확해 보입니다. 하지만 프로그래머에게서 그들이 충분히 똑똑하지 않아 불안하다는 이유로 장난감을 뺏았을 때 어떻게 반응하는지 본 적이 있나요? 네네, 이 세상엔 절대 변하지 않는게 있죠. 1969년에 이 제안은 엄청난 논쟁거리였습니다. <a href="https://en.wikipedia.org/wiki/Donald_Knuth">도널드 커누스</a>는 <code>goto</code>를 <a href="https://scholar.google.com/scholar?cluster=17147143327681396418&amp;hl=en&amp;as_sdt=0,5">옹호</a>했습니다. <code>goto</code>로 전문적인 코드를 작성하는 사람들이 더 제약이 심한 구조에서 다시 프로그래밍을 배워야 한다는 얘기에 분개하는 것도 무리는 아니었습니다. 물론 이를 위해 완전히 새로운 언어 세트를 만들어야 하기도 했으니까요.</p>
<p><img src="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/wolf-and-bulldog.jpg" alt="On the left, a photo of a snarling wolf. On the right, a photo of a grumpy bulldog."></p>
<p>왼쪽: 전통적인 <code>goto</code>. 오른쪽: 길들여진 <code>goto</code>로 C, C#, Golang 등에서 찾아볼 수 있다. 함수 경계를 넘을 수 없다는 것은, 이 녀석이 신발에 오줌을 쌀지언정, 얼굴을 물어뜯지 못한다는 것을 뜻한다.</p>
<p>결국, 현대 언어들은 데이크스트라의 원래 형식보다는 덜 엄격한 형태를 취했습니다. <code>break</code>, <code>continue</code>, <code>return</code> 등을 이용해서 중첩된 구조에서 한 번에 나올 수는 있죠. 하지만 근본적으로 그 경계가 제한된 방식 아래에서만 가능하니, 모두 데이크스트라의 아이디어에 근거하고 있다고 볼 수 있습니다. 특히, 흐름 제어를 감싸 블랙박스화하는데 쓰이는 "함수"는 불가침 영역입니다. 한 함수에서 다른 함수로 <code>break</code> 할 수 없고, <code>return</code>으로 함수에서 현재 함수에서 나올 수는 있지만, 더 이상은 불가합니다. 한 함수 내에서 내부적으로 지지고 볶는 흐름 제어를 한다고 해도, 다른 함수는 신경 쓸 거리 조차 없습니다.</p>
<p>이는 <code>goto</code> 그 자체에도 마찬가지입니다. C, C#, Golang과 같이 <code>goto</code>를 아직 가지고 있는 몇몇 언어들을 찾아볼 수 있습니다. 하지만 상당히 제한된 형태로 추가되어 있죠. 최소한 한 함수에서 다른 함수로 점프할 수 없을 겁니다. 역사적인 어셈블리<sup class="footnote-ref" id="tfnref-2"><a href="#tfn-2">2</a></sup> 언어의 <code>goto</code>는 이제 안녕입니다. 데이크스트라, 당신이 이겼어요.</p>
<h3 id="6">의외의 이득: <code>goto</code>를 없앴더니 생긴 새로운 기능</h3>
<p><code>goto</code>가 없어지고 나니, 흥미로운 일이 일어났습니다. 언어 설계자들이 구조화된 흐름 제어에 의존하는 새로운 기능을 추가할 수 있게 되었습니다.</p>
<p>예를 들면, 파이썬은 자원을 정리하기 위한 <code>with</code>라는 멋진 문법을 가지고 있습니다. 이렇게 쓸 수 있죠.</p>
<pre><code># Python
with open("my-file") as file_handle:
    ...
</code></pre>
<p>이는 <code>...</code> 코드가 실행되는 동안 파일이 열려 있다가, 종료되는 대로 바로 닫히는 것을 보장합니다. 대부분의 현대 언어들은 RAII, <code>using</code>, try-with-resource, <code>defer</code> 와 같은 비슷한 기능을 가지고 있습니다. 그리고 다들 질서 정연하고 체계적으로 코드가 실행될 것을 가정합니다. 우리가 <code>with</code> 블록 내에서 갑자기 <code>goto</code>를 쓰면 ... 어떻게 될까요? 파일은 열려있을까요 닫혀있을까요? 정상적으로 종료하는 대신에 그냥 점프해서 나가버린다면요? 파일은 닫힐까요? 이 기능은 언어에 <code>goto</code>가 있는 한 일관되게 동작할 수 없습니다.</p>
<p>에러 핸들링도 비슷한 문제가 있습니다. 뭔가 잘못되면 코드는 뭘 해야 할까요? 보통은 스택을 호출자에게 돌려주고 알아서 하라고 하는 쪽입니다. 현대적인 언어들은 이 문제를 쉽게 다룰 수 있도록 예외(exception)나, 이와 비슷한 형태의 <a href="https://doc.rust-lang.org/std/result/index.html#the-question-mark-operator-">자동 오류 전파</a> 같은 것들을 가지고 있습니다. 하지만 이것도 스택과 "호출자"라는 신뢰할 수 있는 개념이 있는 경우에만 가능합니다. FLOW-MATIC 프로그램에 있던 흐름 제어를 놓고 그 안에서 예외가 발생했을 때 어떤 일이 일어날지 상상해보세요. 어디로 가야만 할까요?</p>
<h3 id="7"><code>goto</code> 문: 절대 안 돼요</h3>
<p><code>goto</code>, 그러니까 함수 경계를 넘나드는 과거의 <code>goto</code> 라는 건,  단순히 나쁘거나 제대로 쓰기 어려운 기능 정도가 아닙니다. 만약 그랬다면 수없이 많은 나쁜 기능에도 불구하고 살아남았을 겁니다. 하지만 그 정도 수준이 아닙니다.</p>
<blockquote><p>스스로 <code>goto</code>를 사용하지 않는다고 해도, 그게 언어에 존재하는 한 모든 것을 사용하기 어렵게 됩니다. 써드 파티 라이브러리를 쓰려고 해도 블랙박스처럼 다룰 수 없습니다. 어떤 함수가 정상적인 함수인지 아니면 변칙적인 흐름을 가진 함수인지 알아내기 위해 모든 부분을 샅샅이 읽어봐야 합니다. 이래서는 지역적 추론을 할 수가 없습니다. 게다가 자원 정리나 자동 오류 전파 등의 기능도 쓸 수 없습니다. <code>goto</code>를 완전히 버리고 "블랙박스" 룰을 따르는 구조적 흐름 제어를 가지는 편이 낫습니다.</p>
</blockquote>
<h2 id="8"><code>go</code> 문의 해로움</h2>
<p>이렇게 <code>goto</code>의 역사를 살펴보았습니다. 이제 이걸 <code>go</code> 문에 적용해볼까요? 음... 기본적으로 하나부터 열까지 같아요. 과정이 놀랄 정도로 같습니다.</p>
<p><strong>Go 문은 추상화를 깨버립니다.</strong> <code>goto</code>가 가능한 언어에서 어떤 기능들이 <code>goto</code>의 다른 형태로 나타나는지 기억나시나요? 대부분의 동시성 프레임워크에서 <code>go</code> 문은 같은 문제를 일으킵니다. 함수를 호출할 때마다 백그라운드 작업이 생성되거나 생성되지 않을 수 있습니다. 함수는 돌아온 것 같지만 백그라운드에서 아직 실행 중일까요? 소스 코드를 다 읽기 전까지는 알 도리가 없죠. 작업은 언제 종료될까요? 답하기가 어렵군요. <code>go</code> 문이 있는 한, 함수는 흐름 제어와 관련해서 더 이상 블랙박스가 될 수 없습니다. 제가 썼던 <a href="https://vorpus.org/blog/some-thoughts-on-asynchronous-api-design-in-a-post-asyncawait-world/">첫 번째 동시성 API에 대한 글</a>에서 "인과율 위반"이라 칭한 이것이, 다양한 실제적인 문제들의 근본적인 원인임을 찾아냈습니다. asyncio와 Twisted에서의 배압 문제, 제대로 종료되지 않는 문제 등이요.</p>
<p><strong>Go 문은 자동 자원 정리를 불가능하게 합니다.</strong> <code>with</code>를 예로 들어 보겠습니다.</p>
<pre><code># Python
with open("my-file") as file_handle:
    ...
</code></pre>
<p>앞서, 우리는 <code>...</code> 코드가 실행되는 동안 파일이 열려 있을 것을 "보장"받고, 끝나면 닫힌다고 얘기했었죠. 하지만 <code>...</code> 코드에서 백그라운드 작업을 생성한다면 어떻게 될까요? 더 이상 보장할 수 없게 됩니다. <code>with</code> 블록 안에 있는 것처럼 보였던 동작이 실제로는 <code>with</code> 블록이 끝나도 계속 동작하고 있을 수 있고, 그러다가 파일이 닫히면 사용하고 있던 쪽에서는 오류가 발생할 수 있습니다. 다시 한 번 얘기하지만, 이런 식으로는 부분만 봐서 알 수 없게 됩니다. <code>...</code> 코드에서 호출되는 함수의 모든 소스 코드를 살펴봐야만 합니다.</p>
<p>이 코드를 제대로 돌아가게 하려면, 백그라운드로 동작하는 작업들을 어떻게든 추적하고 완료될 때까지 기다려서 파일을 닫아야 합니다. 뭐 가능한 일이긴 하죠. 작업이 끝났을 때 알려주는 라이브러리를 사용하는 한 괴롭긴 하지만 할 수는 있습니다. (예: 나중에 다시 결합(join)될 수 있도록 하는 핸들을 제공하지 않는 경우) 하지만 아무리 최상의 상황을 가정해봐도 비구조적인 흐름 제어하에서는 언어 차원에서 도움을 줄 수가 없습니다. 다시 옛날처럼 수작업으로 자원 정리를 해야만 하겠죠.</p>
<p><strong>Go 문은 오류를 다루지 못하게 합니다.</strong> 위에서 얘기했던 것과 같이, 현대의 언어들은 오류를 검출하고 제대로 전파하는 데 도움을 주는 예외와 같은 강력한 도구를 제공합니다. 하지만 이 도구들도 신뢰할 수 있는 "현재 코드의 호출자"라는 개념에 의존하고 있습니다. 작업을 생성하고 콜백을 등록하면 이 개념은 바로 무너집니다. 제가 아는 한, 많이 사용되는 대부분의 동시성 프레임워크들은 이를 그냥 포기했습니다. 백그라운드 작업에서 오류가 발생했는데, 그걸 수동으로 처리하지 않았다면 런타임은... 이걸 그냥 대충 치워버리고 사실은 중요하지 않았다는냥 행세를 하죠. 운이 좋다면 콘솔에 뭐라도 찍을 수 있었겠네요. (제가 이제까지 썼던 소프트웨어들 중에 "뭔가 인쇄하고 계속 수행해버린다" 전략이 그럭저럭 통했던건 쉰내 나는 포트란 라이브러리 정도였습니다. 이제와서 그러면 안 되죠.) 심지어 Rust마저도 – 전국 고등학생 투표 결과 쓰레드 정합성에 가장 집착한 언어로 꼽힌 – 면죄부를 받을 수는 없습니다. Rust는 <a href="https://doc.rust-lang.org/std/thread/">오류를 버리고 잘 되기를 기원</a>하는 편이죠.</p>
<p>물론 이런 시스템에서도 쓰레드 결합을 조심스럽게 다루거나 <a href="https://twistedmatrix.com/documents/current/core/howto/defer.html#visual-explanation">Twisted의 errbacks</a>나 <a href="https://hackernoon.com/promises-and-error-handling-4a11af37cb0e">JavaScript의 Promise.catch</a>처럼 자체적인 오류 전파 구조를 작성해서 오류를 제대로 다룰 수는 있습니다. 하지만 이미 언어에 있는 기능을 임시변통으로 재구현한 것뿐이죠. "역추적(traceback)"이나 "디버거" 등의 기능은 다 갖다 버리고서요. <code>Promise.catch</code> 한 번만 까먹었다간 갑자기 알아채지도 못했던 심각한 문제가 발생하고 말 겁니다. 이 모든 문제를 해결했다 치더라도, 똑같은 일을 하는 두 개의 너저분한 시스템과 함께해야 할 뿐입니다.</p>
<h3 id="9"><code>go</code> 문: 절대 안 돼요</h3>
<p><code>goto</code>가 최초의 고급 프로그래밍 언어에서 기초 요소로 존재했던 것과 같이, <code>go</code> 또한 최초의 실용적인 동시성 프레임워크에서는 당연히 기초 요소 대접을 받았습니다. 기본 스케쥴러가 실제로 동작하는 방식과 일치하고, 그 어떤 동시성 흐름 패턴도 구현할 만큼 강력하죠. 하지만 <code>goto</code>가 그랬던 것처럼, 추상화를 깨트려, 이게 언어에 존재한다는 것만으로도 모든 일이 어려워집니다.</p>
<p>그럼에도 좋은 소식이 있다면, 이 문제는 이미 완전히 해결되었다는 것이죠. 데이크스트라가 보여줬잖아요? 뭘 해야 하나면,</p>
<ul>
<li><code>go</code>와 같은 기능을 가진 비슷한 것 중에서, "블랙박스 룰"을 따르는 것을 찾기.</li>
<li>동시성 프레임워크에 새로운 구조를 기초 요소로 만들고, <code>go</code> 같은 건 포함하지 말기.</li>
</ul>
<p>이게 바로 Trio가 하는 것입니다.</p>
<h2 id="10">Nursery: <code>go</code>를 대체하는 구조적 용법</h2>
<p>핵심 아이디어를 말씀드리겠습니다. 흐름이 여러 갈래로 갈라질 때마다, 다시 합쳐지는 것을 명확하게 하고자 합니다. 세 가지 일을 한꺼번에 하는 경우를 예로 들자면, 흐름 제어는 아래와 같을 겁니다.</p>
<object class="align-center" data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/nursery-schematic-unlabeled.svg" style="width: 250px;" type="image/svg+xml"> </object><p>하나의 화살표가 위에서 그대로 아래로 가고 있는 것에 주목해 주세요. 바로 데이크스트라의 블랙박스 룰을 따른다는 것이죠. 이제, 이 모습을 어떻게 언어의 견고한 요소로 만들 수 있을까요? 이 제약에 걸맞은 몇 가지 구조가 있습니다만, (a) 제가 제안하려는 건 이제까지의 것들과 조금은 다르고요(특히 독립 실행형 요소로 만들고 싶다는 점에서), (b) 동시성과 관련된 이야기는 너무 방대하고 복잡해서 역사를 따지고 장단점을 구분하려면 삼천포로 빠지는 일이라, 나중에 따로 적도록 하겠습니다. 이 글에서는 제 솔루션을 설명하는 데 집중하겠습니다. 하지만 제가 동시성과 관련된 뭔가를 발명했다는 얘기를 하려는 게 아니고, 여러 곳에서 영감을 끌어다 썼으며, 그저 거인의 어깨 위에서 서 있다는 것만 알아주세요. <sup class="footnote-ref" id="tfnref-3"><a href="#tfn-3">3</a></sup></p>
<p>어쨌거나, 이렇게 해보려고 합니다. 먼저, 부모 작업에서 nursery라 불리는 자식을 위한 장소를 마련하지 않는 한, 그 어떤 자식 작업도 시작하지 못한다고 합시다. <em>nursery 블록</em>을 열어서 시작하죠. 트리오에서는 이걸 <code>async with</code> 문법으로 사용합니다.</p>
<object class="align-center" data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/nursery-1-pathified.svg" style="width: 350px;" type="image/svg+xml"> </object><p>nursery 블록을 엶과 동시에 이 nursery를 나타내는 객체가 생성되고, <code>as nursery</code> 문법을 통해 이를 <code>nursery</code> 라는 변수에 할당합니다. 그 다음 nursery 객체의 <code>start_soon</code> 기능을 통해 동시 작업을 시작할 수 있습니다. 이 경우에 한 작업은 <code>myfunc</code> 함수를 호출하고, 다른 하나는 <code>anotherfunc</code>를 호출하게 됩니다. 개념적으로 이 작업들은 nursery 블록 <em>내부</em>에서 실행됩니다. nursery 블록의 코드들은 블록이 생성됨과 동시에 시작되는 초기 작업들이라고 생각하면 편합니다.</p>
<object class="align-center" data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/nursery-2-pathified.svg" style="width: 500px;" type="image/svg+xml"></object><p>결정적으로, nursery 블록은 그 안의 모든 작업이 종료될 때까지 끝나지 않습니다. 자식 작업이 모두 끝나기 전에 부모 작업이 끝에 다다르면, 멈춰서 끝나길 기다립니다. Nursery가 자동으로 확장되어 자식들을 기다리는 것이죠.</p>
<p>이 흐름을 보시면 이 섹션의 첫 부분에 보여드린 것과 같은 패턴임을 확인할 수 있습니다.</p>
<object class="align-center" data="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/nursery-3-pathified.svg" style="width: 600px;" type="image/svg+xml"> </object><p>이 그림은 여러 중요한 내용을 담고 있지만, 모두 명확하지는 않습니다. 하나씩 알아보죠.</p>
<h3 id="11">Nursery는 함수 추상화를 보존합니다.</h3>
<p><code>go</code> 문의 근본적인 문제는 함수를 호출할 때, 함수가 종료된 뒤에도 백그라운드 작업을 생성하는지 여부를 알 수 없다는 데 있습니다. Nursery와 함께라면 이런 걱정을 할 필요가 없죠. 어떤 함수라도 nursery를 열고 여러 동시 작업을 실행할 수 있지만, 모두 끝날 때까지 함수는 반환되지 않을 겁니다. 그러니까 함수에서 돌아왔다면, 실제로 끝난 겁니다.</p>
<h3 id="12">Nursery는 동적 작업 복제를 지원합니다.</h3>
<p>위의 흐름 제어 다이어그램을 충족시키는 더 단순한 형태가 있습니다. 썽크(thunk) 목록을 받아 모두 동시에 실행합니다.</p>
<pre><code>run_concurrently([myfunc, anotherfunc])
</code></pre>
<p>이런 부류의 문제점은 실행하기 전에 모든 작업의 목록을 알아야 한다는 데 있습니다. 늘 그럴 순 없죠. 예를 들어, 일반적인 서버 프로그램들이 가지고 있는 <code>accept</code> 루프는 들어오는 연결을 받아 개별적인 처리를 위해 새로운 작업을 시작합니다. Trio로 구현된 최소한의 <code>accept</code> 루프를 보시죠.</p>
<pre><code>async with trio.open_nursery() as nursery:
    while True:
        incoming_connection = await server_socket.accept()
        nursery.start_soon(connection_handler, incoming_connection)
</code></pre>
<p>Nursery에서는 굉장히 쉬운 일이지만, <code>run_concurrently</code> 같은 것으로 구현하려면 <em>훨씬</em> 버거울 겁니다. 원한다면 nursery 상에서도 <code>run_concurrently</code> 를 구현할 수 있겠지만, 그 정도로 단순한 경우에는 Nursery 표기법이 훨씬 읽기 쉬우니 그럴 필요가 없습니다.</p>
<h3 id="13">탈출구가 있습니다.</h3>
<p>Nursery 객체는 탈출구도 제공합니다. 백그라운드 작업이 그 자체보다 더 오래 걸리는 백그라운드 작업을 생성하는 경우에는 어떻게 할까요? 간단합니다. 함수에 Nursery 객체를 전달하면 됩니다. <code>async with open_nursery()</code> 블록 안에서만 <code>nursery.start_soon</code>을 호출하라는 법은 없습니다. Nursery 블록이 열려 있는 한<sup class="footnote-ref" id="tfnref-4"><a href="#tfn-4">4</a></sup>, nursery 객체에 참조를 얻을 수 있는 누구라도 nursery 내에 작업을 생성할 수 있습니다. 함수 인자로 전달하거나 대기열에 넣거나, 뭐든지요.</p>
<p>실제로는, 이는 "규칙을 어기는" 함수를 작성할 수 있음을 의미합니다. 몇 가지 제약이 있지만요.</p>
<ul>
<li>Nursery 객체를 명시적으로 전달해야 하므로, 일반적인 흐름 제어를 위반하는 경우를 호출하는 시점에서 즉시 알아낼 수 있습니다. 여전히 지역 추론은 가능합니다.</li>
<li>함수가 생성한 작업들은 전달된 nursery 객체와 생사를 같이하게 됩니다.</li>
<li>호출하는 코드는 자체적으로 접근할 수 있는 nursery 객체 내에서만 전달될 수 있습니다.</li>
</ul>
<p>그러므로 임의의 코드가 영원히 끝나지 않을지도 모를 백그라운드 작업을 생성할 수 있는 기존 모델과는 차별됩니다.</p>
<p>이를 통해 Nursery가 <code>go</code>문과 동등한 표현력을 가짐을 증명할 수도 있지만, 이미 글이 길어지고 있으니 별도로 적도록 하겠습니다.</p>
<h3 id="14">Nursery처럼 동작하는 새로운 타입을 정의할 수 있습니다.</h3>
<p>기본 nursery 문법으로도 충분한 토대를 제공할 수 있지만, 때로는 특별한 것을 원하는 경우도 있습니다. Erlang의 supervisors가 부러워 nursery 유사 클래스에서 자식 작업을 재시작하는 식으로 예외를 다루고 싶은 경우에도 사용될 수 있습니다. 일반적인 nursery와 비슷합니다.</p>
<pre><code>async with my_supervisor_library.open_supervisor() as nursery_alike:
    nursery_alike.start_soon(...)
</code></pre>
<p>Nursery를 인자로 받는 함수가 있을 때, 생성된 작업을 위해 오류 처리를 위한 정책을 제어하는 대신 nursery를 인자로 전달할 수 있습니다. 멋지네요. Trio를 asyncio나 다른 라이브러리들과 구별되게 하는 미묘한 부분이 있습니다. 바로 <code>start_soon</code>이 coroutine 객체나 <code>Future</code>가 아닌 함수를 받는다는 점입니다. (함수는 여러 번 실행될 수 있지만, coroutine 객체나 <code>Future</code>는 그럴 수 없으니까요.) 이게 여러 가지 이유에서(특히 Trio는 <code>Future</code> 같은 게 필요 없으니까) 더 나은 문법이라고 생각하지만, 언급할 필요는 있겠죠</p>
<h3 id="15">아니요, 사실, nursery는 <em>항상</em> 내부 작업이 끝나기를 기다립니다.</h3>
<p>잘못 사용하는 경우에 한해서지만, nursery 불변성을 깨트리는 미묘한 부분이 있을 수 있으므로, 어떻게 작업이 취소되며 작업 결합이 이뤄지는지 설명할 필요가 있겠습니다.</p>
<p>Trio에서 코드는 언제든지 취소 요청을 받을 수 있습니다. 취소가 요청되면, 코드는 그 후에 "체크포인트" 작업을 수행하고, <code>Cancelled</code> 예외를 발생시킵니다. 즉, 취소가 <em>요청된</em> 시점과 실제로 취소가 <em>수행된</em> 시점에 차이가 있다는 것입니다. 작업이 체크포인트를 실행하기까지 시간이 걸리고, 그 이후에 예외가 스택을 따라 돌아가 정리하는 작업을 수행하거나 합니다. 이러한 일이 생겨도, nursery는 정리 작업이 항상 완전히 수행될 때까지 기다립니다. 정리할 기회조차 주지 않고 작업을 종료해 버리거나 완전히 취소되지 않은 상태로 남겨지는 일은 <em>절대로</em> 일어나지 않습니다.</p>
<h3 id="16">자동으로 자원을 정리합니다.</h3>
<p>Nursery는 블랙박스 룰을 따르기에, <code>with</code> 블록을 다시 사용할 수 있습니다. <code>with</code> 블록의 끝에 도달해 파일을 닫아버리는 바람에 백그라운드로 동작하던 작업이 갑자기 종료하는 일은 없습니다.</p>
<h3 id="17">자동으로 오류를 전파합니다.</h3>
<p>위에서 말했듯, 대부분의 동시성 시스템은 백그라운드 작업에서 다루지 못한 에러는 그냥 무시해버리는 편입니다. 말 그대로 그걸로 뭘 할 수 없기 때문입니다.</p>
<p>Trio에서는 모든 작업이 nursery 안에서 이뤄지는데, 모든 nursery는 부모 작업의 일부이므로, 부모 작업은 nursery 내의 작업이 끝나기를 기다려줘야 합니다. 그러니 처리되지 않은 오류를 <em>제대로</em> 다룰 수 있습니다. 백그라운드 작업이 예외와 함께 종료되면, 부모 작업으로 예외를 돌려보낼 수 있습니다. 여기서 nursery를 "동시 호출"을 수행하는 기초 요소로 본다는 것이 핵심입니다. <code>myfunc</code>와 <code>anotherfunc</code>를 동시에 호출하는 예제에서 호출 스택이 트리로 구성됩니다. 그러므로 예외는 일반적인 호출 스택과 같이 트리 구조를 따라 전파될 수 있습니다.</p>
<p>부모 작업에서 예외를 다시 발생시키면, 부모 작업 내에서 전파가 시작된다는 점이 미묘합니다. 일반적으로 이는 부모 작업이 nursery 블록을 종료시킨다는 의미입니다. 하지만 앞서 부모 작업은 자식 작업이 실행되는 동안 nursery 블록을 벗어날 수 없다고 말했었죠. 어떻게 해야 할까요?</p>
<p>자식에서 처리되지 않은 예외가 발생하면 Trio가 nursery 내의 다른 작업을 모두 취소하고 완료될 때까지 기다린 뒤에 예외를 다시 발생시키는 식으로 이 문제를 처리합니다.</p>
<p>이는 프로그래밍 언어에서 nursery를 구현할 때, nursery 코드와 취소 시스템 사이에 일종의 통합이 필요할 수도 있다는 것을 의미합니다. 취소를 위해 객체를 수동으로 전달해야 하는 관례를 가진 C# 이나 Golang과 같은 언어나 일반적인 취소 구현이 없는 언어에서는 다소 까다로운 작업이 될 겁니다.</p>
<h3 id="18">의외의 이득: <code>go</code>를 없앴더니 생긴 새로운 기능</h3>
<p><code>goto</code>를 없애므로 언어 설계자들이 프로그램 구조에 대해 보다 명확한 가정을 할 수 있게 되어 만들 수 있었던 <code>with</code> 블록과 예외 처리와 같이, <code>go</code>를 없앰으로 비슷한 효과가 있었습니다.</p>
<ul>
<li>Trio의 취소 시스템은 작업이 일반적인 트리 구조로 이루어져 있다고 가정할 수 있어, 경쟁자들에 비해 더 쉽고 안정적으로 사용할 수 있습니다. <a href="https://vorpus.org/blog/timeouts-and-cancellation-for-humans/">인간을 위한 시간제한과 취소</a>를 통해 확인해보세요.</li>
<li>Trio는 파이썬 개발자가 기대하는 방식으로 control-C가 동작하는 유일한 파이썬 동시성 라이브러리입니다. (<a href="https://vorpus.org/blog/control-c-handling-in-python-and-trio/">자세히</a>) 이는 nursery와 같이 예외 전파를 위한 신뢰할 수 있는 구조를 제공하지 않으면 불가능한 일입니다.</li>
</ul>
<h2 id="19">Nursery를 써보자</h2>
<p>이제까지 이론적인 것을 알아봤습니다. 실제로는 어떨까요?</p>
<p>음... 해보지 않으면 모를텐데요. 꼭 시도해보고 찾아보세요! 하지만 정말 진지하게 경험해보지 않으면 알 수 없는 부분이 많겠죠. 이 지점에서는 제 얘기가 꽤 그럴싸하게 들릴 거라 확신하긴 하지만, 초기의 구조적 프로그래밍 옹호론자들이 <code>break</code>와 <code>continue</code>를 허용하며 물러난 것과 같이 약간의 변경이 필요하다는 것은 인정해야 할지도 모릅니다.</p>
<p>만약 당신이 경험이 많은 동시성 프로그래머라면 Trio를 배우는데 다소 힘든 시간을 보내야 합니다. 1970년대의 프로그래머가 <code>goto</code> 없이 코드를 배우느라 고생했던 것과 같이 <a href="https://stackoverflow.com/questions/48282841/in-trio-how-can-i-have-a-background-task-that-lives-as-long-as-my-object-does">새로운 방식으로 일하는 법</a>을 배우기도 해야 합니다.</p>
<p>물론 그게 핵심이죠. 커누스는 이렇게(<a href="https://scholar.google.com/scholar?cluster=17147143327681396418&amp;hl=en&amp;as_sdt=0,5">Knuth, 1974</a>, p. 275) 말했습니다.</p>
<blockquote><p>아마도 <code>go to</code>문과 관련하여 저지를 수 있는 가장 큰 실수는 늘 하던 대로 프로그램을 작성한 다음에 <strong>go to</strong>만 싹 제거한 다음에 "구조적 프로그래밍"이라고 부르는 것일 겁니다. 대부분의 <strong>go to</strong>는 애초에 있어야 하지 않을 곳에 있는 겁니다. 우리가 정말로 원하는 것은 애초에 <strong>go to</strong>문을 <em>생각조차</em> 하지 않고 프로그램을 구상하는 것이기 때문입니다. 그게 반드시 필요한 곳은 사실상 거의 없기 때문입니다. 우리가 언어를 통해 아이디어를 구현하는 것은 우리의 사고 과정에 강한 영향을 받습니다. 그런 연유로 데이크스트라는 복잡성에 대한 <strong>go to</strong>의 유혹을 피할 수 있는 언어의 새로운 기능들, 즉 명확한 사고를 장려하는 구조를 요구했던 것입니다.</p>
</blockquote>
<p>이것이 바로 제가 이제까지 nursery를 사용했던 경험과 같습니다. 이는 저를 명확한 사고로 이끌었습니다. 더 견고하고, 사용하기 쉬우며, 전체적으로 나은 디자인으로 이어집니다. 제약 사항들 덕에 불필요한 복잡도를 다루는 일에서 벗어나 문제를 더 쉽게 해결할 수 있게 됩니다. Trio를 사용하는 것은, 실질적인 의미에서 제가 더 나은 프로그래머가 되도록 이끌어 주었습니다.</p>
<p>TCP 연결 맺는 속도를 높이는 단순한 동시성 알고리즘인 Happy Eyeballs 알고리즘(<a href="https://tools.ietf.org/html/rfc8305">RFC 8305</a>)을 생각해봅시다. 개념적으로, 이 알고리즘은 복잡하지 않습니다. 네트워크에 과부하가 걸리지 않도록 시차를 두고 서로 경쟁적으로 연결을 시도하게 하는 것입니다. 그러나 <a href="https://github.com/twisted/twisted/compare/trunk...glyph:statemachine-hostnameendpoint">Twisted의 최적 구현체</a>는 거의 600줄에 달하는 파이썬 코드이며, <a href="https://twistedmatrix.com/trac/ticket/9345">여전히 하나의 로직 버그</a>를 가지고 있는 것을 알 수 있습니다. Trio로 구현한 동일한 결과물의 길이는 1/15밖에 되지 않습니다. 더 중요한 것은, Trio를 사용하여 몇 달이 아니라 몇 분 만에 작성할 수 있었고, 단박에 정확한 로직을 구현했다는 것입니다. 제가 오랫동안 사용했던 그 어떤 프레임워크로도 이렇게 하진 못했습니다. <a href="https://www.youtube.com/watch?v=i-R704I8ySE">지난 달에 Pyninsula에서의 제 발표</a>를 살펴봐 주세요. 뻔한 이야기인가요? 하지만 시간이 말해주겠죠. 저는 유망하다고 봅니다.</p>
<h2 id="20">결론</h2>
<p>인기 있는 동시성 요소들인 – <code>go</code>문, 쓰레드 복제 함수, 콜백, futures, promises, ... 이런 것들은 이론적으로도 실제적으로도 모두 <code>goto</code>의 변형일 뿐입니다. 게다가 현대화된 <code>goto</code>도 아니고 함수 경계를 넘나드는, 호랑이 담배 피우던 시절의 <code>goto</code> 수준입니다. 이런 요소들은 우리가 직접 사용하지 않더래도 매우 위험합니다. 우리가 흐름을 읽어내는 것도 방해하며, 추상화된 모듈식 구성으로 복잡한 시스템을 만들지도 못하게 하며, 자동화된 자원 정리와 오류 전파와 같은 언어 수준의 유용한 기능도 쓰기 힘들게 만들기 때문입니다. 그 결과, 현대의 고급 언어에는 <code>goto</code>는 갈 곳이 없어졌죠.</p>
<p>Nursery는 언어의 기능을 해치지 않으며 안전하고 편리한 대안을 제공할 뿐 아니라, 강력한 새로운 기능(Trio의 취소 범위와 control-C 처리로 입증된)을 제공합니다. 이는 가독성과 생선성, 정확한 구현의 극적인 향상을 이끌어 냅니다.</p>
<p>아쉽게도, 이러한 이점을 충분히 가져가려면, 기존 요소를 완전히 제거하고 아마도 바닥부터 완전히 새로운 동시성 프레임워크를 만들어야 할지도 모릅니다. <code>goto</code>가 없는 새로운 언어를 설계하는 것과 같이요. 하지만 FLOW-MATIC이 나왔을 당시에 인상적이었던 것만큼, 더 좋은 나은 무언가로 좋아지는 것은 반길만한 일입니다. 저는 nursery로 전환하는 것을 후회할 거라 생각하지 않습니다. Trio를 통해 이것이 실용적이며 범용적인 동시성 프레임워크 디자인임은 입증했다고 생각합니다.</p>
<h2 id="21">붙임</h2>
<p>초안을 검토해준 Graydon Hoare, Quentin Pradet, 그리고 Hynek Schlawack에게 감사드립니다. 남아있는 오류는 모두 제 탓입니다.</p>
<p>저작권: FLOW-MATIC 샘플 코드는 <a href="http://www.computerhistory.org/collections/catalog/102646140">컴퓨터 역사 박물관</a>이 보관중인 <a href="http://archive.computerhistory.org/resources/text/Remington_Rand/Univac.Flowmatic.1957.102646140.pdf">이 브로슈어</a> (PDF)에서 발췌.  <a href="https://www.flickr.com/photos/iam_photo/478178221">Wolves in Action</a>, by i:am. photography / Martin Pannier, <a href="https://creativecommons.org/licenses/by-nc-sa/2.0/">CC-BY-SA 2.0 라이센스</a>, cropped.  <a href="https://pixabay.com/en/french-bulldog-pet-dog-funny-2427629/">French Bulldog Pet Dog</a> by Daniel Borker, released under the <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 public domain dedication</a>.</p>
<h2 id="22">각주</h2>
<div class="footnotes">
<hr>
<ol><li id="tfn-1"><p>최소한 특정 부류의 인간에게는.<a href="#tfnref-1" class="footnote">&#8617;</a></p></li>
<li id="tfn-2"><p>WebAssembly는 <code>goto</code> 없이도 충분히 저수준 언어로 사용될 수 있음을 보여주었다: <a href="https://www.w3.org/TR/wasm-core-1/#control-instructions%E2%91%A0">reference</a>, <a href="https://github.com/WebAssembly/design/blob/master/Rationale.md#control-flow">rationale</a><a href="#tfnref-2" class="footnote">&#8617;</a></p></li>
<li id="tfn-3"><p>제가 관심을 기울이고 있는 논문이 어떤 것인지 모르고는 도저히 집중할 수 없는 분들을 위해 알려드리자면, 이 리뷰에 포함된 논문 목록은 다음과 같습니다: the "parallel composition" operator in Cooperating/Communicating Sequential Processes and Occam, the fork/join model, Erlang supervisors, Martin Sústrik's article on <a href="http://250bpm.com/blog:71">Structured concurrency</a> and work on <a href="https://github.com/sustrik/libdill">libdill</a>, and <a href="https://docs.rs/crossbeam/0.3.2/crossbeam/struct.Scope.html">crossbeam::scope</a> / <a href="https://docs.rs/rayon/1.0.1/rayon/fn.scope.html">rayon::scope</a> in Rust. Edit: I've also been pointed to the highly relevant <a href="https://godoc.org/golang.org/x/sync/errgroup">golang.org/x/sync/errgroup</a> and <a href="https://godoc.org/github.com/oklog/run">github.com/oklog/run</a> in Golang. 제가 빼먹은 중요한게 있다면 <a href="mailto:njs@pobox.com">알려주세요</a>.<a href="#tfnref-3" class="footnote">&#8617;</a></p></li>
<li id="tfn-4"><p>Nursery 블록이 종료된 <em>후에</em> <code>start_soon</code>을 호출하면 <code>start_soon</code>은 오류를 발생시키고, 만약 오류가 발생하지 않는다면, nursery 블록은 남은 작업이 끝날 때까지 열린 상태로 유지될 것입니다. 직접 nursery 시스템을 구현하는 경우에 이 부분의 동기화를 신중하게 다뤄야 합니다.<a href="#tfnref-4" class="footnote">&#8617;</a></p></li>
</ol>
</div>
]]></description>
    <pubDate>Mon, 03 Dec 2018 09:02:44 +0000</pubDate>
    
    <author>ez.amiryo@gmail.com (Park Hyunwoo)</author>
    
  </item>
  
</channel>
</rss>